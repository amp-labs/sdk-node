/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod";
import { safeParse } from "../../lib/schemas.js";
import { ClosedEnum } from "../../types/enums.js";
import { Result as SafeParseResult } from "../../types/fp.js";
import { SDKValidationError } from "../errors/sdkvalidationerror.js";

export const GetMyInfoServerList = [
  "https://api.withampersand.com/v1",
] as const;

/**
 * A Problem Details object (RFC 9457).
 *
 * @remarks
 *
 * Additional properties specific to the problem type may be present.
 */
export type GetMyInfoUserResponseBody = {
  /**
   * An absolute URI that identifies the problem type
   */
  type?: string | undefined;
  /**
   * An absolute URI that, when dereferenced, provides human-readable documentation for the problem type (e.g. using HTML).
   */
  href?: string | undefined;
  /**
   * A short summary of the problem type. Written in English and readable for engineers (usually not suited for non technical stakeholders and not localized).
   */
  title?: string | undefined;
  /**
   * The HTTP status code generated by the origin server for this occurrence of the problem.
   */
  status?: number | undefined;
  /**
   * A human-readable explanation specific to this occurrence of the problem
   */
  detail?: string | undefined;
  /**
   * An absolute URI that identifies the specific occurrence of the problem. It may or may not yield further information if dereferenced.
   */
  instance?: string | undefined;
  /**
   * The subsystem that generated the problem
   */
  subsystem?: string | undefined;
  /**
   * The time the problem occurred, formatted as RFC-3339
   */
  time?: Date | undefined;
  /**
   * A unique identifier for the request, useful for debugging
   */
  requestId?: string | undefined;
  /**
   * A list of problems that caused this problem. This can be used to represent multiple
   *
   * @remarks
   * root causes. There is no guaranteed ordering of the causes.
   */
  causes?: Array<string> | undefined;
  /**
   * A brief description of how to resolve the problem
   */
  remedy?: string | undefined;
  /**
   * An email address to contact for support
   */
  supportEmail?: string | undefined;
  /**
   * A phone number to contact for support
   */
  supportPhone?: string | undefined;
  /**
   * A URL to contact for support
   */
  supportUrl?: string | undefined;
  /**
   * Whether the request can be retried
   */
  retryable?: boolean | undefined;
  /**
   * A timestamp after which the request can be retried, formatted as RFC-3339
   */
  retryAfter?: Date | undefined;
  /**
   * Additional context for the problem
   */
  context?: { [k: string]: any } | undefined;
};

export type Builder = {
  /**
   * The builder ID.
   */
  id: string;
  /**
   * The identity provider
   */
  idpProvider: string;
  /**
   * ID used by the identity provider
   */
  idpRef: string;
  /**
   * The time that the builder joined Ampersand.
   */
  createTime: Date;
  firstName?: string | undefined;
  lastName?: string | undefined;
  fullName?: string | undefined;
  primaryEmail?: string | undefined;
};

/**
 * The type of the principal.
 */
export const PrincipalType = {
  Team: "team",
  Builder: "builder",
} as const;
/**
 * The type of the principal.
 */
export type PrincipalType = ClosedEnum<typeof PrincipalType>;

export type GetMyInfoProject = {
  /**
   * The project ID.
   */
  id: string;
  /**
   * The project name.
   */
  name: string;
  /**
   * The name of the application, which is displayed to end users.
   */
  appName: string;
  /**
   * The organization ID that this project belongs to.
   */
  orgId?: string | undefined;
  /**
   * The time the project was created.
   */
  createTime: Date;
  /**
   * The time the project was updated.
   */
  updateTime?: Date | undefined;
};

export type ProjectRoles = {
  /**
   * The role of the builder in the project.
   */
  role: string;
  /**
   * The type of the principal.
   */
  principalType: PrincipalType;
  /**
   * The ID of the team or builder.
   */
  principalId: string;
  project: GetMyInfoProject;
};

/**
 * The type of the principal.
 */
export const GetMyInfoPrincipalType = {
  Team: "team",
  Builder: "builder",
} as const;
/**
 * The type of the principal.
 */
export type GetMyInfoPrincipalType = ClosedEnum<typeof GetMyInfoPrincipalType>;

export type GetMyInfoOrg = {
  /**
   * The organization ID.
   */
  id: string;
  /**
   * The organization label.
   */
  label: string;
  /**
   * The ID of the Everyone team for the org.
   */
  defaultTeamId: string;
  /**
   * The time the organization was created.
   */
  createTime: Date;
  /**
   * The time the organization was updated.
   */
  updateTime?: Date | undefined;
};

export type OrgRole = {
  /**
   * The role of the builder in the org.
   */
  role: string;
  /**
   * The type of the principal.
   */
  principalType: GetMyInfoPrincipalType;
  /**
   * The ID of the team or builder.
   */
  principalId: string;
  org: GetMyInfoOrg;
};

/**
 * Information about the current user and their organizations and projects
 */
export type GetMyInfoResponseBody = {
  builder: Builder;
  /**
   * A map of project IDs to project roles for the builder.
   */
  projectRoles: { [k: string]: ProjectRoles };
  orgRole?: OrgRole | undefined;
};

export type GetMyInfoResponse =
  | GetMyInfoResponseBody
  | GetMyInfoUserResponseBody;

/** @internal */
export const GetMyInfoUserResponseBody$inboundSchema: z.ZodType<
  GetMyInfoUserResponseBody,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: z.string().default("about:blank"),
  href: z.string().optional(),
  title: z.string().optional(),
  status: z.number().int().optional(),
  detail: z.string().optional(),
  instance: z.string().optional(),
  subsystem: z.string().optional(),
  time: z.string().datetime({ offset: true }).transform(v => new Date(v))
    .optional(),
  requestId: z.string().optional(),
  causes: z.array(z.string()).optional(),
  remedy: z.string().optional(),
  supportEmail: z.string().optional(),
  supportPhone: z.string().optional(),
  supportUrl: z.string().optional(),
  retryable: z.boolean().optional(),
  retryAfter: z.string().datetime({ offset: true }).transform(v => new Date(v))
    .optional(),
  context: z.record(z.any()).optional(),
});

/** @internal */
export type GetMyInfoUserResponseBody$Outbound = {
  type: string;
  href?: string | undefined;
  title?: string | undefined;
  status?: number | undefined;
  detail?: string | undefined;
  instance?: string | undefined;
  subsystem?: string | undefined;
  time?: string | undefined;
  requestId?: string | undefined;
  causes?: Array<string> | undefined;
  remedy?: string | undefined;
  supportEmail?: string | undefined;
  supportPhone?: string | undefined;
  supportUrl?: string | undefined;
  retryable?: boolean | undefined;
  retryAfter?: string | undefined;
  context?: { [k: string]: any } | undefined;
};

/** @internal */
export const GetMyInfoUserResponseBody$outboundSchema: z.ZodType<
  GetMyInfoUserResponseBody$Outbound,
  z.ZodTypeDef,
  GetMyInfoUserResponseBody
> = z.object({
  type: z.string().default("about:blank"),
  href: z.string().optional(),
  title: z.string().optional(),
  status: z.number().int().optional(),
  detail: z.string().optional(),
  instance: z.string().optional(),
  subsystem: z.string().optional(),
  time: z.date().transform(v => v.toISOString()).optional(),
  requestId: z.string().optional(),
  causes: z.array(z.string()).optional(),
  remedy: z.string().optional(),
  supportEmail: z.string().optional(),
  supportPhone: z.string().optional(),
  supportUrl: z.string().optional(),
  retryable: z.boolean().optional(),
  retryAfter: z.date().transform(v => v.toISOString()).optional(),
  context: z.record(z.any()).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace GetMyInfoUserResponseBody$ {
  /** @deprecated use `GetMyInfoUserResponseBody$inboundSchema` instead. */
  export const inboundSchema = GetMyInfoUserResponseBody$inboundSchema;
  /** @deprecated use `GetMyInfoUserResponseBody$outboundSchema` instead. */
  export const outboundSchema = GetMyInfoUserResponseBody$outboundSchema;
  /** @deprecated use `GetMyInfoUserResponseBody$Outbound` instead. */
  export type Outbound = GetMyInfoUserResponseBody$Outbound;
}

export function getMyInfoUserResponseBodyToJSON(
  getMyInfoUserResponseBody: GetMyInfoUserResponseBody,
): string {
  return JSON.stringify(
    GetMyInfoUserResponseBody$outboundSchema.parse(getMyInfoUserResponseBody),
  );
}

export function getMyInfoUserResponseBodyFromJSON(
  jsonString: string,
): SafeParseResult<GetMyInfoUserResponseBody, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GetMyInfoUserResponseBody$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetMyInfoUserResponseBody' from JSON`,
  );
}

/** @internal */
export const Builder$inboundSchema: z.ZodType<Builder, z.ZodTypeDef, unknown> =
  z.object({
    id: z.string(),
    idpProvider: z.string(),
    idpRef: z.string(),
    createTime: z.string().datetime({ offset: true }).transform(v =>
      new Date(v)
    ),
    firstName: z.string().optional(),
    lastName: z.string().optional(),
    fullName: z.string().optional(),
    primaryEmail: z.string().optional(),
  });

/** @internal */
export type Builder$Outbound = {
  id: string;
  idpProvider: string;
  idpRef: string;
  createTime: string;
  firstName?: string | undefined;
  lastName?: string | undefined;
  fullName?: string | undefined;
  primaryEmail?: string | undefined;
};

/** @internal */
export const Builder$outboundSchema: z.ZodType<
  Builder$Outbound,
  z.ZodTypeDef,
  Builder
> = z.object({
  id: z.string(),
  idpProvider: z.string(),
  idpRef: z.string(),
  createTime: z.date().transform(v => v.toISOString()),
  firstName: z.string().optional(),
  lastName: z.string().optional(),
  fullName: z.string().optional(),
  primaryEmail: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Builder$ {
  /** @deprecated use `Builder$inboundSchema` instead. */
  export const inboundSchema = Builder$inboundSchema;
  /** @deprecated use `Builder$outboundSchema` instead. */
  export const outboundSchema = Builder$outboundSchema;
  /** @deprecated use `Builder$Outbound` instead. */
  export type Outbound = Builder$Outbound;
}

export function builderToJSON(builder: Builder): string {
  return JSON.stringify(Builder$outboundSchema.parse(builder));
}

export function builderFromJSON(
  jsonString: string,
): SafeParseResult<Builder, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Builder$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Builder' from JSON`,
  );
}

/** @internal */
export const PrincipalType$inboundSchema: z.ZodNativeEnum<
  typeof PrincipalType
> = z.nativeEnum(PrincipalType);

/** @internal */
export const PrincipalType$outboundSchema: z.ZodNativeEnum<
  typeof PrincipalType
> = PrincipalType$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace PrincipalType$ {
  /** @deprecated use `PrincipalType$inboundSchema` instead. */
  export const inboundSchema = PrincipalType$inboundSchema;
  /** @deprecated use `PrincipalType$outboundSchema` instead. */
  export const outboundSchema = PrincipalType$outboundSchema;
}

/** @internal */
export const GetMyInfoProject$inboundSchema: z.ZodType<
  GetMyInfoProject,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  name: z.string(),
  appName: z.string(),
  orgId: z.string().optional(),
  createTime: z.string().datetime({ offset: true }).transform(v => new Date(v)),
  updateTime: z.string().datetime({ offset: true }).transform(v => new Date(v))
    .optional(),
});

/** @internal */
export type GetMyInfoProject$Outbound = {
  id: string;
  name: string;
  appName: string;
  orgId?: string | undefined;
  createTime: string;
  updateTime?: string | undefined;
};

/** @internal */
export const GetMyInfoProject$outboundSchema: z.ZodType<
  GetMyInfoProject$Outbound,
  z.ZodTypeDef,
  GetMyInfoProject
> = z.object({
  id: z.string(),
  name: z.string(),
  appName: z.string(),
  orgId: z.string().optional(),
  createTime: z.date().transform(v => v.toISOString()),
  updateTime: z.date().transform(v => v.toISOString()).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace GetMyInfoProject$ {
  /** @deprecated use `GetMyInfoProject$inboundSchema` instead. */
  export const inboundSchema = GetMyInfoProject$inboundSchema;
  /** @deprecated use `GetMyInfoProject$outboundSchema` instead. */
  export const outboundSchema = GetMyInfoProject$outboundSchema;
  /** @deprecated use `GetMyInfoProject$Outbound` instead. */
  export type Outbound = GetMyInfoProject$Outbound;
}

export function getMyInfoProjectToJSON(
  getMyInfoProject: GetMyInfoProject,
): string {
  return JSON.stringify(
    GetMyInfoProject$outboundSchema.parse(getMyInfoProject),
  );
}

export function getMyInfoProjectFromJSON(
  jsonString: string,
): SafeParseResult<GetMyInfoProject, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GetMyInfoProject$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetMyInfoProject' from JSON`,
  );
}

/** @internal */
export const ProjectRoles$inboundSchema: z.ZodType<
  ProjectRoles,
  z.ZodTypeDef,
  unknown
> = z.object({
  role: z.string(),
  principalType: PrincipalType$inboundSchema,
  principalId: z.string(),
  project: z.lazy(() => GetMyInfoProject$inboundSchema),
});

/** @internal */
export type ProjectRoles$Outbound = {
  role: string;
  principalType: string;
  principalId: string;
  project: GetMyInfoProject$Outbound;
};

/** @internal */
export const ProjectRoles$outboundSchema: z.ZodType<
  ProjectRoles$Outbound,
  z.ZodTypeDef,
  ProjectRoles
> = z.object({
  role: z.string(),
  principalType: PrincipalType$outboundSchema,
  principalId: z.string(),
  project: z.lazy(() => GetMyInfoProject$outboundSchema),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ProjectRoles$ {
  /** @deprecated use `ProjectRoles$inboundSchema` instead. */
  export const inboundSchema = ProjectRoles$inboundSchema;
  /** @deprecated use `ProjectRoles$outboundSchema` instead. */
  export const outboundSchema = ProjectRoles$outboundSchema;
  /** @deprecated use `ProjectRoles$Outbound` instead. */
  export type Outbound = ProjectRoles$Outbound;
}

export function projectRolesToJSON(projectRoles: ProjectRoles): string {
  return JSON.stringify(ProjectRoles$outboundSchema.parse(projectRoles));
}

export function projectRolesFromJSON(
  jsonString: string,
): SafeParseResult<ProjectRoles, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ProjectRoles$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ProjectRoles' from JSON`,
  );
}

/** @internal */
export const GetMyInfoPrincipalType$inboundSchema: z.ZodNativeEnum<
  typeof GetMyInfoPrincipalType
> = z.nativeEnum(GetMyInfoPrincipalType);

/** @internal */
export const GetMyInfoPrincipalType$outboundSchema: z.ZodNativeEnum<
  typeof GetMyInfoPrincipalType
> = GetMyInfoPrincipalType$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace GetMyInfoPrincipalType$ {
  /** @deprecated use `GetMyInfoPrincipalType$inboundSchema` instead. */
  export const inboundSchema = GetMyInfoPrincipalType$inboundSchema;
  /** @deprecated use `GetMyInfoPrincipalType$outboundSchema` instead. */
  export const outboundSchema = GetMyInfoPrincipalType$outboundSchema;
}

/** @internal */
export const GetMyInfoOrg$inboundSchema: z.ZodType<
  GetMyInfoOrg,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  label: z.string(),
  defaultTeamId: z.string(),
  createTime: z.string().datetime({ offset: true }).transform(v => new Date(v)),
  updateTime: z.string().datetime({ offset: true }).transform(v => new Date(v))
    .optional(),
});

/** @internal */
export type GetMyInfoOrg$Outbound = {
  id: string;
  label: string;
  defaultTeamId: string;
  createTime: string;
  updateTime?: string | undefined;
};

/** @internal */
export const GetMyInfoOrg$outboundSchema: z.ZodType<
  GetMyInfoOrg$Outbound,
  z.ZodTypeDef,
  GetMyInfoOrg
> = z.object({
  id: z.string(),
  label: z.string(),
  defaultTeamId: z.string(),
  createTime: z.date().transform(v => v.toISOString()),
  updateTime: z.date().transform(v => v.toISOString()).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace GetMyInfoOrg$ {
  /** @deprecated use `GetMyInfoOrg$inboundSchema` instead. */
  export const inboundSchema = GetMyInfoOrg$inboundSchema;
  /** @deprecated use `GetMyInfoOrg$outboundSchema` instead. */
  export const outboundSchema = GetMyInfoOrg$outboundSchema;
  /** @deprecated use `GetMyInfoOrg$Outbound` instead. */
  export type Outbound = GetMyInfoOrg$Outbound;
}

export function getMyInfoOrgToJSON(getMyInfoOrg: GetMyInfoOrg): string {
  return JSON.stringify(GetMyInfoOrg$outboundSchema.parse(getMyInfoOrg));
}

export function getMyInfoOrgFromJSON(
  jsonString: string,
): SafeParseResult<GetMyInfoOrg, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GetMyInfoOrg$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetMyInfoOrg' from JSON`,
  );
}

/** @internal */
export const OrgRole$inboundSchema: z.ZodType<OrgRole, z.ZodTypeDef, unknown> =
  z.object({
    role: z.string(),
    principalType: GetMyInfoPrincipalType$inboundSchema,
    principalId: z.string(),
    org: z.lazy(() => GetMyInfoOrg$inboundSchema),
  });

/** @internal */
export type OrgRole$Outbound = {
  role: string;
  principalType: string;
  principalId: string;
  org: GetMyInfoOrg$Outbound;
};

/** @internal */
export const OrgRole$outboundSchema: z.ZodType<
  OrgRole$Outbound,
  z.ZodTypeDef,
  OrgRole
> = z.object({
  role: z.string(),
  principalType: GetMyInfoPrincipalType$outboundSchema,
  principalId: z.string(),
  org: z.lazy(() => GetMyInfoOrg$outboundSchema),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OrgRole$ {
  /** @deprecated use `OrgRole$inboundSchema` instead. */
  export const inboundSchema = OrgRole$inboundSchema;
  /** @deprecated use `OrgRole$outboundSchema` instead. */
  export const outboundSchema = OrgRole$outboundSchema;
  /** @deprecated use `OrgRole$Outbound` instead. */
  export type Outbound = OrgRole$Outbound;
}

export function orgRoleToJSON(orgRole: OrgRole): string {
  return JSON.stringify(OrgRole$outboundSchema.parse(orgRole));
}

export function orgRoleFromJSON(
  jsonString: string,
): SafeParseResult<OrgRole, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => OrgRole$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'OrgRole' from JSON`,
  );
}

/** @internal */
export const GetMyInfoResponseBody$inboundSchema: z.ZodType<
  GetMyInfoResponseBody,
  z.ZodTypeDef,
  unknown
> = z.object({
  builder: z.lazy(() => Builder$inboundSchema),
  projectRoles: z.record(z.lazy(() => ProjectRoles$inboundSchema)),
  orgRole: z.lazy(() => OrgRole$inboundSchema).optional(),
});

/** @internal */
export type GetMyInfoResponseBody$Outbound = {
  builder: Builder$Outbound;
  projectRoles: { [k: string]: ProjectRoles$Outbound };
  orgRole?: OrgRole$Outbound | undefined;
};

/** @internal */
export const GetMyInfoResponseBody$outboundSchema: z.ZodType<
  GetMyInfoResponseBody$Outbound,
  z.ZodTypeDef,
  GetMyInfoResponseBody
> = z.object({
  builder: z.lazy(() => Builder$outboundSchema),
  projectRoles: z.record(z.lazy(() => ProjectRoles$outboundSchema)),
  orgRole: z.lazy(() => OrgRole$outboundSchema).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace GetMyInfoResponseBody$ {
  /** @deprecated use `GetMyInfoResponseBody$inboundSchema` instead. */
  export const inboundSchema = GetMyInfoResponseBody$inboundSchema;
  /** @deprecated use `GetMyInfoResponseBody$outboundSchema` instead. */
  export const outboundSchema = GetMyInfoResponseBody$outboundSchema;
  /** @deprecated use `GetMyInfoResponseBody$Outbound` instead. */
  export type Outbound = GetMyInfoResponseBody$Outbound;
}

export function getMyInfoResponseBodyToJSON(
  getMyInfoResponseBody: GetMyInfoResponseBody,
): string {
  return JSON.stringify(
    GetMyInfoResponseBody$outboundSchema.parse(getMyInfoResponseBody),
  );
}

export function getMyInfoResponseBodyFromJSON(
  jsonString: string,
): SafeParseResult<GetMyInfoResponseBody, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GetMyInfoResponseBody$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetMyInfoResponseBody' from JSON`,
  );
}

/** @internal */
export const GetMyInfoResponse$inboundSchema: z.ZodType<
  GetMyInfoResponse,
  z.ZodTypeDef,
  unknown
> = z.union([
  z.lazy(() => GetMyInfoResponseBody$inboundSchema),
  z.lazy(() => GetMyInfoUserResponseBody$inboundSchema),
]);

/** @internal */
export type GetMyInfoResponse$Outbound =
  | GetMyInfoResponseBody$Outbound
  | GetMyInfoUserResponseBody$Outbound;

/** @internal */
export const GetMyInfoResponse$outboundSchema: z.ZodType<
  GetMyInfoResponse$Outbound,
  z.ZodTypeDef,
  GetMyInfoResponse
> = z.union([
  z.lazy(() => GetMyInfoResponseBody$outboundSchema),
  z.lazy(() => GetMyInfoUserResponseBody$outboundSchema),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace GetMyInfoResponse$ {
  /** @deprecated use `GetMyInfoResponse$inboundSchema` instead. */
  export const inboundSchema = GetMyInfoResponse$inboundSchema;
  /** @deprecated use `GetMyInfoResponse$outboundSchema` instead. */
  export const outboundSchema = GetMyInfoResponse$outboundSchema;
  /** @deprecated use `GetMyInfoResponse$Outbound` instead. */
  export type Outbound = GetMyInfoResponse$Outbound;
}

export function getMyInfoResponseToJSON(
  getMyInfoResponse: GetMyInfoResponse,
): string {
  return JSON.stringify(
    GetMyInfoResponse$outboundSchema.parse(getMyInfoResponse),
  );
}

export function getMyInfoResponseFromJSON(
  jsonString: string,
): SafeParseResult<GetMyInfoResponse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GetMyInfoResponse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetMyInfoResponse' from JSON`,
  );
}
