/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod";
import { remap as remap$ } from "../../lib/primitives.js";
import { safeParse } from "../../lib/schemas.js";
import { ClosedEnum } from "../../types/enums.js";
import { Result as SafeParseResult } from "../../types/fp.js";
import { SDKValidationError } from "../errors/sdkvalidationerror.js";

export const UpdateInstallationServerList = [
  "https://api.withampersand.com/v1",
] as const;

/**
 * If selectedFieldsAuto is set to all, all fields will be read.
 */
export const SelectedFieldsAuto = {
  All: "all",
} as const;
/**
 * If selectedFieldsAuto is set to all, all fields will be read.
 */
export type SelectedFieldsAuto = ClosedEnum<typeof SelectedFieldsAuto>;

export type UpdateInstallationDefaultPeriod = {
  /**
   * Number of days in past to backfill from. 0 is no backfill. e.g) if 10, then backfill last 10 days of data. Required if fullHistory is not set.
   */
  days?: number | undefined;
  /**
   * If true, backfill all history. Required if days is not set.
   */
  fullHistory?: boolean | undefined;
};

export type UpdateInstallationBackfill = {
  defaultPeriod: UpdateInstallationDefaultPeriod;
};

export type UpdateInstallationObjects = {
  /**
   * The name of the object to read from.
   */
  objectName?: string | undefined;
  /**
   * The schedule for reading the object, in cron syntax.
   */
  schedule?: string | undefined;
  /**
   * The name of the destination that the result should be sent to.
   */
  destination?: string | undefined;
  /**
   * This is a map of field names to booleans indicating whether they should be read. If a field is already included in `selectedFieldMappings`, it does not need to be included here.
   */
  selectedFields?: { [k: string]: boolean } | undefined;
  /**
   * This is a map of field names to their value mappings.
   */
  selectedValueMappings?: { [k: string]: { [k: string]: string } } | undefined;
  /**
   * This is a map of mapToNames to field names. (A mapTo name is the name the builder wants to map a field to when it lands in their destination.)
   */
  selectedFieldMappings?: { [k: string]: string } | undefined;
  /**
   * If selectedFieldsAuto is set to all, all fields will be read.
   */
  selectedFieldsAuto?: SelectedFieldsAuto | undefined;
  backfill?: UpdateInstallationBackfill | undefined;
};

export type UpdateInstallationRead = {
  /**
   * This is a map of object names to their configuration.
   */
  objects?: { [k: string]: UpdateInstallationObjects } | undefined;
};

/**
 * Whether the default value should be applied when updating a record.
 *
 * @remarks
 * If set to `always`, the default value will be applied when updating a record.
 * If set to `never`, the default value will not be applied when updating a record,
 * only when creating a record.
 * If unspecified, then `always` is assumed.
 */
export const UpdateInstallationSelectedValueDefaultsApplyOnUpdate = {
  Always: "always",
  Never: "never",
} as const;
/**
 * Whether the default value should be applied when updating a record.
 *
 * @remarks
 * If set to `always`, the default value will be applied when updating a record.
 * If set to `never`, the default value will not be applied when updating a record,
 * only when creating a record.
 * If unspecified, then `always` is assumed.
 */
export type UpdateInstallationSelectedValueDefaultsApplyOnUpdate = ClosedEnum<
  typeof UpdateInstallationSelectedValueDefaultsApplyOnUpdate
>;

export type Three = {
  /**
   * The value to be used as a default.
   */
  value: boolean;
  /**
   * Whether the default value should be applied when updating a record.
   *
   * @remarks
   * If set to `always`, the default value will be applied when updating a record.
   * If set to `never`, the default value will not be applied when updating a record,
   * only when creating a record.
   * If unspecified, then `always` is assumed.
   */
  applyOnUpdate?:
    | UpdateInstallationSelectedValueDefaultsApplyOnUpdate
    | undefined;
};

/**
 * Whether the default value should be applied when updating a record.
 *
 * @remarks
 * If set to `always`, the default value will be applied when updating a record.
 * If set to `never`, the default value will not be applied when updating a record,
 * only when creating a record.
 * If unspecified, then `always` is assumed.
 */
export const SelectedValueDefaultsApplyOnUpdate = {
  Always: "always",
  Never: "never",
} as const;
/**
 * Whether the default value should be applied when updating a record.
 *
 * @remarks
 * If set to `always`, the default value will be applied when updating a record.
 * If set to `never`, the default value will not be applied when updating a record,
 * only when creating a record.
 * If unspecified, then `always` is assumed.
 */
export type SelectedValueDefaultsApplyOnUpdate = ClosedEnum<
  typeof SelectedValueDefaultsApplyOnUpdate
>;

export type SelectedValueDefaults2 = {
  /**
   * The value to be used as a default.
   */
  value: number;
  /**
   * Whether the default value should be applied when updating a record.
   *
   * @remarks
   * If set to `always`, the default value will be applied when updating a record.
   * If set to `never`, the default value will not be applied when updating a record,
   * only when creating a record.
   * If unspecified, then `always` is assumed.
   */
  applyOnUpdate?: SelectedValueDefaultsApplyOnUpdate | undefined;
};

/**
 * Whether the default value should be applied when updating a record.
 *
 * @remarks
 * If set to `always`, the default value will be applied when updating a record.
 * If set to `never`, the default value will not be applied when updating a record,
 * only when creating a record.
 * If unspecified, then `always` is assumed.
 */
export const ApplyOnUpdate = {
  Always: "always",
  Never: "never",
} as const;
/**
 * Whether the default value should be applied when updating a record.
 *
 * @remarks
 * If set to `always`, the default value will be applied when updating a record.
 * If set to `never`, the default value will not be applied when updating a record,
 * only when creating a record.
 * If unspecified, then `always` is assumed.
 */
export type ApplyOnUpdate = ClosedEnum<typeof ApplyOnUpdate>;

export type SelectedValueDefaults1 = {
  /**
   * The value to be used as a default.
   */
  value: string;
  /**
   * Whether the default value should be applied when updating a record.
   *
   * @remarks
   * If set to `always`, the default value will be applied when updating a record.
   * If set to `never`, the default value will not be applied when updating a record,
   * only when creating a record.
   * If unspecified, then `always` is assumed.
   */
  applyOnUpdate?: ApplyOnUpdate | undefined;
};

export type SelectedValueDefaults =
  | SelectedValueDefaults1
  | SelectedValueDefaults2
  | Three;

export type UpdateInstallationInstallationsObjects = {
  /**
   * The name of the object to write to.
   */
  objectName?: string | undefined;
  /**
   * This is a map of field names to default values. These values will be used when writing to the object.
   */
  selectedValueDefaults?: {
    [k: string]: SelectedValueDefaults1 | SelectedValueDefaults2 | Three;
  } | undefined;
};

export type UpdateInstallationWrite = {
  /**
   * This is a map of object names to their configuration.
   */
  objects?: { [k: string]: UpdateInstallationInstallationsObjects } | undefined;
};

export type UpdateInstallationProxy = {
  enabled?: boolean | undefined;
};

export type UpdateInstallationContent = {
  /**
   * The SaaS API that we are integrating with.
   */
  provider?: string | undefined;
  read?: UpdateInstallationRead | undefined;
  write?: UpdateInstallationWrite | undefined;
  proxy?: UpdateInstallationProxy | undefined;
};

/**
 * The config of the installation.
 */
export type UpdateInstallationConfig = {
  /**
   * The ID of the revision that this config is based on.
   */
  revisionId?: string | undefined;
  /**
   * The person who created the config, in the format of "consumer:{consumer-id}" or "builder:{builder-id}".
   */
  createdBy?: string | undefined;
  /**
   * The content of the config.
   */
  content?: UpdateInstallationContent | undefined;
};

/**
 * The installation fields to update. (Only include the fields you'd like to update.)
 */
export type Installation = {
  /**
   * The ID of the SaaS connection tied to this installation.
   */
  connectionId?: string | undefined;
  /**
   * The config of the installation.
   */
  config?: UpdateInstallationConfig | undefined;
};

export type UpdateInstallationRequestBody = {
  updateMask: Array<string>;
  /**
   * The installation fields to update. (Only include the fields you'd like to update.)
   */
  installation: Installation;
};

export type UpdateInstallationRequest = {
  projectIdOrName: string;
  integrationId: string;
  installationId: string;
  requestBody: UpdateInstallationRequestBody;
};

/**
 * A Problem Details object (RFC 9457).
 *
 * @remarks
 *
 * Additional properties specific to the problem type may be present.
 */
export type UpdateInstallationInstallationsResponseBody = {
  /**
   * An absolute URI that identifies the problem type
   */
  type?: string | undefined;
  /**
   * An absolute URI that, when dereferenced, provides human-readable documentation for the problem type (e.g. using HTML).
   */
  href?: string | undefined;
  /**
   * A short summary of the problem type. Written in English and readable for engineers (usually not suited for non technical stakeholders and not localized).
   */
  title?: string | undefined;
  /**
   * The HTTP status code generated by the origin server for this occurrence of the problem.
   */
  status?: number | undefined;
  /**
   * A human-readable explanation specific to this occurrence of the problem
   */
  detail?: string | undefined;
  /**
   * An absolute URI that identifies the specific occurrence of the problem. It may or may not yield further information if dereferenced.
   */
  instance?: string | undefined;
  /**
   * The subsystem that generated the problem
   */
  subsystem?: string | undefined;
  /**
   * The time the problem occurred, formatted as RFC-3339
   */
  time?: Date | undefined;
  /**
   * A unique identifier for the request, useful for debugging
   */
  requestId?: string | undefined;
  /**
   * A list of problems that caused this problem. This can be used to represent multiple
   *
   * @remarks
   * root causes. There is no guaranteed ordering of the causes.
   */
  causes?: Array<string> | undefined;
  /**
   * A brief description of how to resolve the problem
   */
  remedy?: string | undefined;
  /**
   * An email address to contact for support
   */
  supportEmail?: string | undefined;
  /**
   * A phone number to contact for support
   */
  supportPhone?: string | undefined;
  /**
   * A URL to contact for support
   */
  supportUrl?: string | undefined;
  /**
   * Whether the request can be retried
   */
  retryable?: boolean | undefined;
  /**
   * A timestamp after which the request can be retried, formatted as RFC-3339
   */
  retryAfter?: Date | undefined;
  /**
   * Additional context for the problem
   */
  context?: { [k: string]: any } | undefined;
};

export type UpdateInstallationGroup = {
  /**
   * The ID of the user group that has access to this installation.
   */
  groupRef: string;
  /**
   * The name of the user group that has access to this installation.
   */
  groupName: string;
  /**
   * The Ampersand project ID.
   */
  projectId: string;
  /**
   * The time the group was created.
   */
  createTime: Date;
  /**
   * The time the group was last updated.
   */
  updateTime?: Date | undefined;
};

export type UpdateInstallationProviderApp = {
  /**
   * The provider app ID.
   */
  id: string;
  /**
   * The Ampersand project ID.
   */
  projectId: string;
  /**
   * The ID used by the provider to identify the app (optional).
   */
  externalRef?: string | undefined;
  /**
   * The SaaS provider that this app connects to.
   */
  provider: string;
  /**
   * The OAuth client ID for this app.
   */
  clientId: string;
  /**
   * The OAuth scopes for this app.
   */
  scopes?: Array<string> | undefined;
  /**
   * The time the provider app was created.
   */
  createTime: Date;
  /**
   * The time the provider app was updated.
   */
  updateTime?: Date | undefined;
};

export type UpdateInstallationInstallationsGroup = {
  /**
   * The ID of the user group that has access to this installation.
   */
  groupRef: string;
  /**
   * The name of the user group that has access to this installation.
   */
  groupName: string;
  /**
   * The Ampersand project ID.
   */
  projectId: string;
  /**
   * The time the group was created.
   */
  createTime: Date;
  /**
   * The time the group was last updated.
   */
  updateTime?: Date | undefined;
};

export type UpdateInstallationConsumer = {
  /**
   * The consumer reference.
   */
  consumerRef: string;
  /**
   * The name of the consumer.
   */
  consumerName: string;
  /**
   * The Ampersand project ID.
   */
  projectId: string;
  /**
   * The time the consumer was created.
   */
  createTime: Date;
  /**
   * The time the consumer was last updated.
   */
  updateTime?: Date | undefined;
};

/**
 * The authentication scheme used for this connection.
 */
export const UpdateInstallationAuthScheme = {
  None: "none",
  ApiKey: "apiKey",
  Basic: "basic",
  Oauth2AuthorizationCode: "oauth2/authorizationCode",
  Oauth2AuthorizationCodePKCE: "oauth2/authorizationCodePKCE",
  Oauth2ClientCredentials: "oauth2/clientCredentials",
  Oauth2Password: "oauth2/password",
} as const;
/**
 * The authentication scheme used for this connection.
 */
export type UpdateInstallationAuthScheme = ClosedEnum<
  typeof UpdateInstallationAuthScheme
>;

/**
 * The status of the connection.
 */
export const UpdateInstallationStatus = {
  Created: "created",
  Working: "working",
  BadCredentials: "bad_credentials",
} as const;
/**
 * The status of the connection.
 */
export type UpdateInstallationStatus = ClosedEnum<
  typeof UpdateInstallationStatus
>;

/**
 * The access token for the connection.
 */
export type UpdateInstallationAccessToken = {
  token: string;
};

/**
 * The refresh token to use for the connection.
 */
export type UpdateInstallationRefreshToken = {
  token: string;
};

export type UpdateInstallationOauth2AuthorizationCode = {
  /**
   * The access token for the connection.
   */
  accessToken?: UpdateInstallationAccessToken | undefined;
  /**
   * The refresh token to use for the connection.
   */
  refreshToken?: UpdateInstallationRefreshToken | undefined;
  /**
   * The scopes for the tokens.
   */
  scopes?: Array<string> | undefined;
};

export type UpdateInstallationConnection = {
  /**
   * The connection ID.
   */
  id: string;
  /**
   * The Ampersand project ID.
   */
  projectId: string;
  /**
   * The SaaS provider that this Connection is for.
   */
  provider: string;
  providerApp?: UpdateInstallationProviderApp | undefined;
  group: UpdateInstallationInstallationsGroup;
  consumer: UpdateInstallationConsumer;
  /**
   * If available, the identifier for the provider workspace (e.g. "salesforce-instance-domain")
   */
  providerWorkspaceRef?: string | undefined;
  /**
   * If available, the ID that Salesforce/Hubspot uses to identify this user (e.g. Salesforce has IDs in the form of https://login.salesforce.com/id/00D4x0000019CQTEA2/0054x000000orJ4AA)
   */
  providerConsumerRef?: string | undefined;
  /**
   * The time the connection was created.
   */
  createTime: Date;
  /**
   * The time the connection was last updated.
   */
  updateTime?: Date | undefined;
  /**
   * The authentication scheme used for this connection.
   */
  authScheme: UpdateInstallationAuthScheme;
  /**
   * The status of the connection.
   */
  status: UpdateInstallationStatus;
  oauth2AuthorizationCode?:
    | UpdateInstallationOauth2AuthorizationCode
    | undefined;
  /**
   * The API key used while making the connection.
   */
  apiKey?: string | undefined;
};

export type UpdateInstallationInstallationsProxy = {
  enabled?: boolean | undefined;
};

export type UpdateInstallationInstallationsContent = {
  /**
   * The SaaS API that we are integrating with.
   */
  provider: string;
  read?: any | undefined;
  write?: any | undefined;
  proxy?: UpdateInstallationInstallationsProxy | undefined;
};

export type UpdateInstallationInstallationsConfig = {
  /**
   * The config ID.
   */
  id: string;
  /**
   * The ID of the revision that this config is based on.
   */
  revisionId: string;
  /**
   * The time the config was created.
   */
  createTime: Date;
  /**
   * The person who created the config, in the format of "consumer:{consumer-id}" or "builder:{builder-id}".
   */
  createdBy: string;
  content: UpdateInstallationInstallationsContent;
};

/**
 * The updated installation
 */
export type UpdateInstallationResponseBody = {
  /**
   * The installation ID.
   */
  id: string;
  /**
   * The Ampersand project ID.
   */
  projectId: string;
  /**
   * The integration ID.
   */
  integrationId: string;
  group?: UpdateInstallationGroup | undefined;
  /**
   * The health status of the installation ("healthy", "unhealthy").
   */
  healthStatus: string;
  connection: UpdateInstallationConnection;
  /**
   * The time the integration was first installed.
   */
  createTime: Date;
  /**
   * The person who did the installation, in the format of "consumer:{consumer-id}".
   */
  createdBy: string;
  /**
   * The time the installation was last updated with a new config.
   */
  updateTime?: Date | undefined;
  config: UpdateInstallationInstallationsConfig;
};

export type UpdateInstallationResponse =
  | UpdateInstallationResponseBody
  | UpdateInstallationInstallationsResponseBody;

/** @internal */
export const SelectedFieldsAuto$inboundSchema: z.ZodNativeEnum<
  typeof SelectedFieldsAuto
> = z.nativeEnum(SelectedFieldsAuto);

/** @internal */
export const SelectedFieldsAuto$outboundSchema: z.ZodNativeEnum<
  typeof SelectedFieldsAuto
> = SelectedFieldsAuto$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace SelectedFieldsAuto$ {
  /** @deprecated use `SelectedFieldsAuto$inboundSchema` instead. */
  export const inboundSchema = SelectedFieldsAuto$inboundSchema;
  /** @deprecated use `SelectedFieldsAuto$outboundSchema` instead. */
  export const outboundSchema = SelectedFieldsAuto$outboundSchema;
}

/** @internal */
export const UpdateInstallationDefaultPeriod$inboundSchema: z.ZodType<
  UpdateInstallationDefaultPeriod,
  z.ZodTypeDef,
  unknown
> = z.object({
  days: z.number().int().optional(),
  fullHistory: z.boolean().optional(),
});

/** @internal */
export type UpdateInstallationDefaultPeriod$Outbound = {
  days?: number | undefined;
  fullHistory?: boolean | undefined;
};

/** @internal */
export const UpdateInstallationDefaultPeriod$outboundSchema: z.ZodType<
  UpdateInstallationDefaultPeriod$Outbound,
  z.ZodTypeDef,
  UpdateInstallationDefaultPeriod
> = z.object({
  days: z.number().int().optional(),
  fullHistory: z.boolean().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace UpdateInstallationDefaultPeriod$ {
  /** @deprecated use `UpdateInstallationDefaultPeriod$inboundSchema` instead. */
  export const inboundSchema = UpdateInstallationDefaultPeriod$inboundSchema;
  /** @deprecated use `UpdateInstallationDefaultPeriod$outboundSchema` instead. */
  export const outboundSchema = UpdateInstallationDefaultPeriod$outboundSchema;
  /** @deprecated use `UpdateInstallationDefaultPeriod$Outbound` instead. */
  export type Outbound = UpdateInstallationDefaultPeriod$Outbound;
}

export function updateInstallationDefaultPeriodToJSON(
  updateInstallationDefaultPeriod: UpdateInstallationDefaultPeriod,
): string {
  return JSON.stringify(
    UpdateInstallationDefaultPeriod$outboundSchema.parse(
      updateInstallationDefaultPeriod,
    ),
  );
}

export function updateInstallationDefaultPeriodFromJSON(
  jsonString: string,
): SafeParseResult<UpdateInstallationDefaultPeriod, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdateInstallationDefaultPeriod$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdateInstallationDefaultPeriod' from JSON`,
  );
}

/** @internal */
export const UpdateInstallationBackfill$inboundSchema: z.ZodType<
  UpdateInstallationBackfill,
  z.ZodTypeDef,
  unknown
> = z.object({
  defaultPeriod: z.lazy(() => UpdateInstallationDefaultPeriod$inboundSchema),
});

/** @internal */
export type UpdateInstallationBackfill$Outbound = {
  defaultPeriod: UpdateInstallationDefaultPeriod$Outbound;
};

/** @internal */
export const UpdateInstallationBackfill$outboundSchema: z.ZodType<
  UpdateInstallationBackfill$Outbound,
  z.ZodTypeDef,
  UpdateInstallationBackfill
> = z.object({
  defaultPeriod: z.lazy(() => UpdateInstallationDefaultPeriod$outboundSchema),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace UpdateInstallationBackfill$ {
  /** @deprecated use `UpdateInstallationBackfill$inboundSchema` instead. */
  export const inboundSchema = UpdateInstallationBackfill$inboundSchema;
  /** @deprecated use `UpdateInstallationBackfill$outboundSchema` instead. */
  export const outboundSchema = UpdateInstallationBackfill$outboundSchema;
  /** @deprecated use `UpdateInstallationBackfill$Outbound` instead. */
  export type Outbound = UpdateInstallationBackfill$Outbound;
}

export function updateInstallationBackfillToJSON(
  updateInstallationBackfill: UpdateInstallationBackfill,
): string {
  return JSON.stringify(
    UpdateInstallationBackfill$outboundSchema.parse(updateInstallationBackfill),
  );
}

export function updateInstallationBackfillFromJSON(
  jsonString: string,
): SafeParseResult<UpdateInstallationBackfill, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdateInstallationBackfill$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdateInstallationBackfill' from JSON`,
  );
}

/** @internal */
export const UpdateInstallationObjects$inboundSchema: z.ZodType<
  UpdateInstallationObjects,
  z.ZodTypeDef,
  unknown
> = z.object({
  objectName: z.string().optional(),
  schedule: z.string().optional(),
  destination: z.string().optional(),
  selectedFields: z.record(z.boolean()).optional(),
  selectedValueMappings: z.record(z.record(z.string())).optional(),
  selectedFieldMappings: z.record(z.string()).optional(),
  selectedFieldsAuto: SelectedFieldsAuto$inboundSchema.optional(),
  backfill: z.lazy(() => UpdateInstallationBackfill$inboundSchema).optional(),
});

/** @internal */
export type UpdateInstallationObjects$Outbound = {
  objectName?: string | undefined;
  schedule?: string | undefined;
  destination?: string | undefined;
  selectedFields?: { [k: string]: boolean } | undefined;
  selectedValueMappings?: { [k: string]: { [k: string]: string } } | undefined;
  selectedFieldMappings?: { [k: string]: string } | undefined;
  selectedFieldsAuto?: string | undefined;
  backfill?: UpdateInstallationBackfill$Outbound | undefined;
};

/** @internal */
export const UpdateInstallationObjects$outboundSchema: z.ZodType<
  UpdateInstallationObjects$Outbound,
  z.ZodTypeDef,
  UpdateInstallationObjects
> = z.object({
  objectName: z.string().optional(),
  schedule: z.string().optional(),
  destination: z.string().optional(),
  selectedFields: z.record(z.boolean()).optional(),
  selectedValueMappings: z.record(z.record(z.string())).optional(),
  selectedFieldMappings: z.record(z.string()).optional(),
  selectedFieldsAuto: SelectedFieldsAuto$outboundSchema.optional(),
  backfill: z.lazy(() => UpdateInstallationBackfill$outboundSchema).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace UpdateInstallationObjects$ {
  /** @deprecated use `UpdateInstallationObjects$inboundSchema` instead. */
  export const inboundSchema = UpdateInstallationObjects$inboundSchema;
  /** @deprecated use `UpdateInstallationObjects$outboundSchema` instead. */
  export const outboundSchema = UpdateInstallationObjects$outboundSchema;
  /** @deprecated use `UpdateInstallationObjects$Outbound` instead. */
  export type Outbound = UpdateInstallationObjects$Outbound;
}

export function updateInstallationObjectsToJSON(
  updateInstallationObjects: UpdateInstallationObjects,
): string {
  return JSON.stringify(
    UpdateInstallationObjects$outboundSchema.parse(updateInstallationObjects),
  );
}

export function updateInstallationObjectsFromJSON(
  jsonString: string,
): SafeParseResult<UpdateInstallationObjects, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdateInstallationObjects$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdateInstallationObjects' from JSON`,
  );
}

/** @internal */
export const UpdateInstallationRead$inboundSchema: z.ZodType<
  UpdateInstallationRead,
  z.ZodTypeDef,
  unknown
> = z.object({
  objects: z.record(z.lazy(() => UpdateInstallationObjects$inboundSchema))
    .optional(),
});

/** @internal */
export type UpdateInstallationRead$Outbound = {
  objects?: { [k: string]: UpdateInstallationObjects$Outbound } | undefined;
};

/** @internal */
export const UpdateInstallationRead$outboundSchema: z.ZodType<
  UpdateInstallationRead$Outbound,
  z.ZodTypeDef,
  UpdateInstallationRead
> = z.object({
  objects: z.record(z.lazy(() => UpdateInstallationObjects$outboundSchema))
    .optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace UpdateInstallationRead$ {
  /** @deprecated use `UpdateInstallationRead$inboundSchema` instead. */
  export const inboundSchema = UpdateInstallationRead$inboundSchema;
  /** @deprecated use `UpdateInstallationRead$outboundSchema` instead. */
  export const outboundSchema = UpdateInstallationRead$outboundSchema;
  /** @deprecated use `UpdateInstallationRead$Outbound` instead. */
  export type Outbound = UpdateInstallationRead$Outbound;
}

export function updateInstallationReadToJSON(
  updateInstallationRead: UpdateInstallationRead,
): string {
  return JSON.stringify(
    UpdateInstallationRead$outboundSchema.parse(updateInstallationRead),
  );
}

export function updateInstallationReadFromJSON(
  jsonString: string,
): SafeParseResult<UpdateInstallationRead, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdateInstallationRead$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdateInstallationRead' from JSON`,
  );
}

/** @internal */
export const UpdateInstallationSelectedValueDefaultsApplyOnUpdate$inboundSchema:
  z.ZodNativeEnum<typeof UpdateInstallationSelectedValueDefaultsApplyOnUpdate> =
    z.nativeEnum(UpdateInstallationSelectedValueDefaultsApplyOnUpdate);

/** @internal */
export const UpdateInstallationSelectedValueDefaultsApplyOnUpdate$outboundSchema:
  z.ZodNativeEnum<typeof UpdateInstallationSelectedValueDefaultsApplyOnUpdate> =
    UpdateInstallationSelectedValueDefaultsApplyOnUpdate$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace UpdateInstallationSelectedValueDefaultsApplyOnUpdate$ {
  /** @deprecated use `UpdateInstallationSelectedValueDefaultsApplyOnUpdate$inboundSchema` instead. */
  export const inboundSchema =
    UpdateInstallationSelectedValueDefaultsApplyOnUpdate$inboundSchema;
  /** @deprecated use `UpdateInstallationSelectedValueDefaultsApplyOnUpdate$outboundSchema` instead. */
  export const outboundSchema =
    UpdateInstallationSelectedValueDefaultsApplyOnUpdate$outboundSchema;
}

/** @internal */
export const Three$inboundSchema: z.ZodType<Three, z.ZodTypeDef, unknown> = z
  .object({
    value: z.boolean(),
    applyOnUpdate:
      UpdateInstallationSelectedValueDefaultsApplyOnUpdate$inboundSchema
        .optional(),
  });

/** @internal */
export type Three$Outbound = {
  value: boolean;
  applyOnUpdate?: string | undefined;
};

/** @internal */
export const Three$outboundSchema: z.ZodType<
  Three$Outbound,
  z.ZodTypeDef,
  Three
> = z.object({
  value: z.boolean(),
  applyOnUpdate:
    UpdateInstallationSelectedValueDefaultsApplyOnUpdate$outboundSchema
      .optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Three$ {
  /** @deprecated use `Three$inboundSchema` instead. */
  export const inboundSchema = Three$inboundSchema;
  /** @deprecated use `Three$outboundSchema` instead. */
  export const outboundSchema = Three$outboundSchema;
  /** @deprecated use `Three$Outbound` instead. */
  export type Outbound = Three$Outbound;
}

export function threeToJSON(three: Three): string {
  return JSON.stringify(Three$outboundSchema.parse(three));
}

export function threeFromJSON(
  jsonString: string,
): SafeParseResult<Three, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Three$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Three' from JSON`,
  );
}

/** @internal */
export const SelectedValueDefaultsApplyOnUpdate$inboundSchema: z.ZodNativeEnum<
  typeof SelectedValueDefaultsApplyOnUpdate
> = z.nativeEnum(SelectedValueDefaultsApplyOnUpdate);

/** @internal */
export const SelectedValueDefaultsApplyOnUpdate$outboundSchema: z.ZodNativeEnum<
  typeof SelectedValueDefaultsApplyOnUpdate
> = SelectedValueDefaultsApplyOnUpdate$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace SelectedValueDefaultsApplyOnUpdate$ {
  /** @deprecated use `SelectedValueDefaultsApplyOnUpdate$inboundSchema` instead. */
  export const inboundSchema = SelectedValueDefaultsApplyOnUpdate$inboundSchema;
  /** @deprecated use `SelectedValueDefaultsApplyOnUpdate$outboundSchema` instead. */
  export const outboundSchema =
    SelectedValueDefaultsApplyOnUpdate$outboundSchema;
}

/** @internal */
export const SelectedValueDefaults2$inboundSchema: z.ZodType<
  SelectedValueDefaults2,
  z.ZodTypeDef,
  unknown
> = z.object({
  value: z.number().int(),
  applyOnUpdate: SelectedValueDefaultsApplyOnUpdate$inboundSchema.optional(),
});

/** @internal */
export type SelectedValueDefaults2$Outbound = {
  value: number;
  applyOnUpdate?: string | undefined;
};

/** @internal */
export const SelectedValueDefaults2$outboundSchema: z.ZodType<
  SelectedValueDefaults2$Outbound,
  z.ZodTypeDef,
  SelectedValueDefaults2
> = z.object({
  value: z.number().int(),
  applyOnUpdate: SelectedValueDefaultsApplyOnUpdate$outboundSchema.optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace SelectedValueDefaults2$ {
  /** @deprecated use `SelectedValueDefaults2$inboundSchema` instead. */
  export const inboundSchema = SelectedValueDefaults2$inboundSchema;
  /** @deprecated use `SelectedValueDefaults2$outboundSchema` instead. */
  export const outboundSchema = SelectedValueDefaults2$outboundSchema;
  /** @deprecated use `SelectedValueDefaults2$Outbound` instead. */
  export type Outbound = SelectedValueDefaults2$Outbound;
}

export function selectedValueDefaults2ToJSON(
  selectedValueDefaults2: SelectedValueDefaults2,
): string {
  return JSON.stringify(
    SelectedValueDefaults2$outboundSchema.parse(selectedValueDefaults2),
  );
}

export function selectedValueDefaults2FromJSON(
  jsonString: string,
): SafeParseResult<SelectedValueDefaults2, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => SelectedValueDefaults2$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'SelectedValueDefaults2' from JSON`,
  );
}

/** @internal */
export const ApplyOnUpdate$inboundSchema: z.ZodNativeEnum<
  typeof ApplyOnUpdate
> = z.nativeEnum(ApplyOnUpdate);

/** @internal */
export const ApplyOnUpdate$outboundSchema: z.ZodNativeEnum<
  typeof ApplyOnUpdate
> = ApplyOnUpdate$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ApplyOnUpdate$ {
  /** @deprecated use `ApplyOnUpdate$inboundSchema` instead. */
  export const inboundSchema = ApplyOnUpdate$inboundSchema;
  /** @deprecated use `ApplyOnUpdate$outboundSchema` instead. */
  export const outboundSchema = ApplyOnUpdate$outboundSchema;
}

/** @internal */
export const SelectedValueDefaults1$inboundSchema: z.ZodType<
  SelectedValueDefaults1,
  z.ZodTypeDef,
  unknown
> = z.object({
  value: z.string(),
  applyOnUpdate: ApplyOnUpdate$inboundSchema.optional(),
});

/** @internal */
export type SelectedValueDefaults1$Outbound = {
  value: string;
  applyOnUpdate?: string | undefined;
};

/** @internal */
export const SelectedValueDefaults1$outboundSchema: z.ZodType<
  SelectedValueDefaults1$Outbound,
  z.ZodTypeDef,
  SelectedValueDefaults1
> = z.object({
  value: z.string(),
  applyOnUpdate: ApplyOnUpdate$outboundSchema.optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace SelectedValueDefaults1$ {
  /** @deprecated use `SelectedValueDefaults1$inboundSchema` instead. */
  export const inboundSchema = SelectedValueDefaults1$inboundSchema;
  /** @deprecated use `SelectedValueDefaults1$outboundSchema` instead. */
  export const outboundSchema = SelectedValueDefaults1$outboundSchema;
  /** @deprecated use `SelectedValueDefaults1$Outbound` instead. */
  export type Outbound = SelectedValueDefaults1$Outbound;
}

export function selectedValueDefaults1ToJSON(
  selectedValueDefaults1: SelectedValueDefaults1,
): string {
  return JSON.stringify(
    SelectedValueDefaults1$outboundSchema.parse(selectedValueDefaults1),
  );
}

export function selectedValueDefaults1FromJSON(
  jsonString: string,
): SafeParseResult<SelectedValueDefaults1, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => SelectedValueDefaults1$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'SelectedValueDefaults1' from JSON`,
  );
}

/** @internal */
export const SelectedValueDefaults$inboundSchema: z.ZodType<
  SelectedValueDefaults,
  z.ZodTypeDef,
  unknown
> = z.union([
  z.lazy(() => SelectedValueDefaults1$inboundSchema),
  z.lazy(() => SelectedValueDefaults2$inboundSchema),
  z.lazy(() => Three$inboundSchema),
]);

/** @internal */
export type SelectedValueDefaults$Outbound =
  | SelectedValueDefaults1$Outbound
  | SelectedValueDefaults2$Outbound
  | Three$Outbound;

/** @internal */
export const SelectedValueDefaults$outboundSchema: z.ZodType<
  SelectedValueDefaults$Outbound,
  z.ZodTypeDef,
  SelectedValueDefaults
> = z.union([
  z.lazy(() => SelectedValueDefaults1$outboundSchema),
  z.lazy(() => SelectedValueDefaults2$outboundSchema),
  z.lazy(() => Three$outboundSchema),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace SelectedValueDefaults$ {
  /** @deprecated use `SelectedValueDefaults$inboundSchema` instead. */
  export const inboundSchema = SelectedValueDefaults$inboundSchema;
  /** @deprecated use `SelectedValueDefaults$outboundSchema` instead. */
  export const outboundSchema = SelectedValueDefaults$outboundSchema;
  /** @deprecated use `SelectedValueDefaults$Outbound` instead. */
  export type Outbound = SelectedValueDefaults$Outbound;
}

export function selectedValueDefaultsToJSON(
  selectedValueDefaults: SelectedValueDefaults,
): string {
  return JSON.stringify(
    SelectedValueDefaults$outboundSchema.parse(selectedValueDefaults),
  );
}

export function selectedValueDefaultsFromJSON(
  jsonString: string,
): SafeParseResult<SelectedValueDefaults, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => SelectedValueDefaults$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'SelectedValueDefaults' from JSON`,
  );
}

/** @internal */
export const UpdateInstallationInstallationsObjects$inboundSchema: z.ZodType<
  UpdateInstallationInstallationsObjects,
  z.ZodTypeDef,
  unknown
> = z.object({
  objectName: z.string().optional(),
  selectedValueDefaults: z.record(
    z.union([
      z.lazy(() => SelectedValueDefaults1$inboundSchema),
      z.lazy(() => SelectedValueDefaults2$inboundSchema),
      z.lazy(() => Three$inboundSchema),
    ]),
  ).optional(),
});

/** @internal */
export type UpdateInstallationInstallationsObjects$Outbound = {
  objectName?: string | undefined;
  selectedValueDefaults?: {
    [k: string]:
      | SelectedValueDefaults1$Outbound
      | SelectedValueDefaults2$Outbound
      | Three$Outbound;
  } | undefined;
};

/** @internal */
export const UpdateInstallationInstallationsObjects$outboundSchema: z.ZodType<
  UpdateInstallationInstallationsObjects$Outbound,
  z.ZodTypeDef,
  UpdateInstallationInstallationsObjects
> = z.object({
  objectName: z.string().optional(),
  selectedValueDefaults: z.record(
    z.union([
      z.lazy(() => SelectedValueDefaults1$outboundSchema),
      z.lazy(() => SelectedValueDefaults2$outboundSchema),
      z.lazy(() => Three$outboundSchema),
    ]),
  ).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace UpdateInstallationInstallationsObjects$ {
  /** @deprecated use `UpdateInstallationInstallationsObjects$inboundSchema` instead. */
  export const inboundSchema =
    UpdateInstallationInstallationsObjects$inboundSchema;
  /** @deprecated use `UpdateInstallationInstallationsObjects$outboundSchema` instead. */
  export const outboundSchema =
    UpdateInstallationInstallationsObjects$outboundSchema;
  /** @deprecated use `UpdateInstallationInstallationsObjects$Outbound` instead. */
  export type Outbound = UpdateInstallationInstallationsObjects$Outbound;
}

export function updateInstallationInstallationsObjectsToJSON(
  updateInstallationInstallationsObjects:
    UpdateInstallationInstallationsObjects,
): string {
  return JSON.stringify(
    UpdateInstallationInstallationsObjects$outboundSchema.parse(
      updateInstallationInstallationsObjects,
    ),
  );
}

export function updateInstallationInstallationsObjectsFromJSON(
  jsonString: string,
): SafeParseResult<UpdateInstallationInstallationsObjects, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      UpdateInstallationInstallationsObjects$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdateInstallationInstallationsObjects' from JSON`,
  );
}

/** @internal */
export const UpdateInstallationWrite$inboundSchema: z.ZodType<
  UpdateInstallationWrite,
  z.ZodTypeDef,
  unknown
> = z.object({
  objects: z.record(
    z.lazy(() => UpdateInstallationInstallationsObjects$inboundSchema),
  ).optional(),
});

/** @internal */
export type UpdateInstallationWrite$Outbound = {
  objects?:
    | { [k: string]: UpdateInstallationInstallationsObjects$Outbound }
    | undefined;
};

/** @internal */
export const UpdateInstallationWrite$outboundSchema: z.ZodType<
  UpdateInstallationWrite$Outbound,
  z.ZodTypeDef,
  UpdateInstallationWrite
> = z.object({
  objects: z.record(
    z.lazy(() => UpdateInstallationInstallationsObjects$outboundSchema),
  ).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace UpdateInstallationWrite$ {
  /** @deprecated use `UpdateInstallationWrite$inboundSchema` instead. */
  export const inboundSchema = UpdateInstallationWrite$inboundSchema;
  /** @deprecated use `UpdateInstallationWrite$outboundSchema` instead. */
  export const outboundSchema = UpdateInstallationWrite$outboundSchema;
  /** @deprecated use `UpdateInstallationWrite$Outbound` instead. */
  export type Outbound = UpdateInstallationWrite$Outbound;
}

export function updateInstallationWriteToJSON(
  updateInstallationWrite: UpdateInstallationWrite,
): string {
  return JSON.stringify(
    UpdateInstallationWrite$outboundSchema.parse(updateInstallationWrite),
  );
}

export function updateInstallationWriteFromJSON(
  jsonString: string,
): SafeParseResult<UpdateInstallationWrite, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdateInstallationWrite$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdateInstallationWrite' from JSON`,
  );
}

/** @internal */
export const UpdateInstallationProxy$inboundSchema: z.ZodType<
  UpdateInstallationProxy,
  z.ZodTypeDef,
  unknown
> = z.object({
  enabled: z.boolean().optional(),
});

/** @internal */
export type UpdateInstallationProxy$Outbound = {
  enabled?: boolean | undefined;
};

/** @internal */
export const UpdateInstallationProxy$outboundSchema: z.ZodType<
  UpdateInstallationProxy$Outbound,
  z.ZodTypeDef,
  UpdateInstallationProxy
> = z.object({
  enabled: z.boolean().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace UpdateInstallationProxy$ {
  /** @deprecated use `UpdateInstallationProxy$inboundSchema` instead. */
  export const inboundSchema = UpdateInstallationProxy$inboundSchema;
  /** @deprecated use `UpdateInstallationProxy$outboundSchema` instead. */
  export const outboundSchema = UpdateInstallationProxy$outboundSchema;
  /** @deprecated use `UpdateInstallationProxy$Outbound` instead. */
  export type Outbound = UpdateInstallationProxy$Outbound;
}

export function updateInstallationProxyToJSON(
  updateInstallationProxy: UpdateInstallationProxy,
): string {
  return JSON.stringify(
    UpdateInstallationProxy$outboundSchema.parse(updateInstallationProxy),
  );
}

export function updateInstallationProxyFromJSON(
  jsonString: string,
): SafeParseResult<UpdateInstallationProxy, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdateInstallationProxy$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdateInstallationProxy' from JSON`,
  );
}

/** @internal */
export const UpdateInstallationContent$inboundSchema: z.ZodType<
  UpdateInstallationContent,
  z.ZodTypeDef,
  unknown
> = z.object({
  provider: z.string().optional(),
  read: z.lazy(() => UpdateInstallationRead$inboundSchema).optional(),
  write: z.lazy(() => UpdateInstallationWrite$inboundSchema).optional(),
  proxy: z.lazy(() => UpdateInstallationProxy$inboundSchema).optional(),
});

/** @internal */
export type UpdateInstallationContent$Outbound = {
  provider?: string | undefined;
  read?: UpdateInstallationRead$Outbound | undefined;
  write?: UpdateInstallationWrite$Outbound | undefined;
  proxy?: UpdateInstallationProxy$Outbound | undefined;
};

/** @internal */
export const UpdateInstallationContent$outboundSchema: z.ZodType<
  UpdateInstallationContent$Outbound,
  z.ZodTypeDef,
  UpdateInstallationContent
> = z.object({
  provider: z.string().optional(),
  read: z.lazy(() => UpdateInstallationRead$outboundSchema).optional(),
  write: z.lazy(() => UpdateInstallationWrite$outboundSchema).optional(),
  proxy: z.lazy(() => UpdateInstallationProxy$outboundSchema).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace UpdateInstallationContent$ {
  /** @deprecated use `UpdateInstallationContent$inboundSchema` instead. */
  export const inboundSchema = UpdateInstallationContent$inboundSchema;
  /** @deprecated use `UpdateInstallationContent$outboundSchema` instead. */
  export const outboundSchema = UpdateInstallationContent$outboundSchema;
  /** @deprecated use `UpdateInstallationContent$Outbound` instead. */
  export type Outbound = UpdateInstallationContent$Outbound;
}

export function updateInstallationContentToJSON(
  updateInstallationContent: UpdateInstallationContent,
): string {
  return JSON.stringify(
    UpdateInstallationContent$outboundSchema.parse(updateInstallationContent),
  );
}

export function updateInstallationContentFromJSON(
  jsonString: string,
): SafeParseResult<UpdateInstallationContent, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdateInstallationContent$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdateInstallationContent' from JSON`,
  );
}

/** @internal */
export const UpdateInstallationConfig$inboundSchema: z.ZodType<
  UpdateInstallationConfig,
  z.ZodTypeDef,
  unknown
> = z.object({
  revisionId: z.string().optional(),
  createdBy: z.string().optional(),
  content: z.lazy(() => UpdateInstallationContent$inboundSchema).optional(),
});

/** @internal */
export type UpdateInstallationConfig$Outbound = {
  revisionId?: string | undefined;
  createdBy?: string | undefined;
  content?: UpdateInstallationContent$Outbound | undefined;
};

/** @internal */
export const UpdateInstallationConfig$outboundSchema: z.ZodType<
  UpdateInstallationConfig$Outbound,
  z.ZodTypeDef,
  UpdateInstallationConfig
> = z.object({
  revisionId: z.string().optional(),
  createdBy: z.string().optional(),
  content: z.lazy(() => UpdateInstallationContent$outboundSchema).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace UpdateInstallationConfig$ {
  /** @deprecated use `UpdateInstallationConfig$inboundSchema` instead. */
  export const inboundSchema = UpdateInstallationConfig$inboundSchema;
  /** @deprecated use `UpdateInstallationConfig$outboundSchema` instead. */
  export const outboundSchema = UpdateInstallationConfig$outboundSchema;
  /** @deprecated use `UpdateInstallationConfig$Outbound` instead. */
  export type Outbound = UpdateInstallationConfig$Outbound;
}

export function updateInstallationConfigToJSON(
  updateInstallationConfig: UpdateInstallationConfig,
): string {
  return JSON.stringify(
    UpdateInstallationConfig$outboundSchema.parse(updateInstallationConfig),
  );
}

export function updateInstallationConfigFromJSON(
  jsonString: string,
): SafeParseResult<UpdateInstallationConfig, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdateInstallationConfig$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdateInstallationConfig' from JSON`,
  );
}

/** @internal */
export const Installation$inboundSchema: z.ZodType<
  Installation,
  z.ZodTypeDef,
  unknown
> = z.object({
  connectionId: z.string().optional(),
  config: z.lazy(() => UpdateInstallationConfig$inboundSchema).optional(),
});

/** @internal */
export type Installation$Outbound = {
  connectionId?: string | undefined;
  config?: UpdateInstallationConfig$Outbound | undefined;
};

/** @internal */
export const Installation$outboundSchema: z.ZodType<
  Installation$Outbound,
  z.ZodTypeDef,
  Installation
> = z.object({
  connectionId: z.string().optional(),
  config: z.lazy(() => UpdateInstallationConfig$outboundSchema).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Installation$ {
  /** @deprecated use `Installation$inboundSchema` instead. */
  export const inboundSchema = Installation$inboundSchema;
  /** @deprecated use `Installation$outboundSchema` instead. */
  export const outboundSchema = Installation$outboundSchema;
  /** @deprecated use `Installation$Outbound` instead. */
  export type Outbound = Installation$Outbound;
}

export function installationToJSON(installation: Installation): string {
  return JSON.stringify(Installation$outboundSchema.parse(installation));
}

export function installationFromJSON(
  jsonString: string,
): SafeParseResult<Installation, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Installation$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Installation' from JSON`,
  );
}

/** @internal */
export const UpdateInstallationRequestBody$inboundSchema: z.ZodType<
  UpdateInstallationRequestBody,
  z.ZodTypeDef,
  unknown
> = z.object({
  updateMask: z.array(z.string()),
  installation: z.lazy(() => Installation$inboundSchema),
});

/** @internal */
export type UpdateInstallationRequestBody$Outbound = {
  updateMask: Array<string>;
  installation: Installation$Outbound;
};

/** @internal */
export const UpdateInstallationRequestBody$outboundSchema: z.ZodType<
  UpdateInstallationRequestBody$Outbound,
  z.ZodTypeDef,
  UpdateInstallationRequestBody
> = z.object({
  updateMask: z.array(z.string()),
  installation: z.lazy(() => Installation$outboundSchema),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace UpdateInstallationRequestBody$ {
  /** @deprecated use `UpdateInstallationRequestBody$inboundSchema` instead. */
  export const inboundSchema = UpdateInstallationRequestBody$inboundSchema;
  /** @deprecated use `UpdateInstallationRequestBody$outboundSchema` instead. */
  export const outboundSchema = UpdateInstallationRequestBody$outboundSchema;
  /** @deprecated use `UpdateInstallationRequestBody$Outbound` instead. */
  export type Outbound = UpdateInstallationRequestBody$Outbound;
}

export function updateInstallationRequestBodyToJSON(
  updateInstallationRequestBody: UpdateInstallationRequestBody,
): string {
  return JSON.stringify(
    UpdateInstallationRequestBody$outboundSchema.parse(
      updateInstallationRequestBody,
    ),
  );
}

export function updateInstallationRequestBodyFromJSON(
  jsonString: string,
): SafeParseResult<UpdateInstallationRequestBody, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdateInstallationRequestBody$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdateInstallationRequestBody' from JSON`,
  );
}

/** @internal */
export const UpdateInstallationRequest$inboundSchema: z.ZodType<
  UpdateInstallationRequest,
  z.ZodTypeDef,
  unknown
> = z.object({
  projectIdOrName: z.string(),
  integrationId: z.string(),
  installationId: z.string(),
  RequestBody: z.lazy(() => UpdateInstallationRequestBody$inboundSchema),
}).transform((v) => {
  return remap$(v, {
    "RequestBody": "requestBody",
  });
});

/** @internal */
export type UpdateInstallationRequest$Outbound = {
  projectIdOrName: string;
  integrationId: string;
  installationId: string;
  RequestBody: UpdateInstallationRequestBody$Outbound;
};

/** @internal */
export const UpdateInstallationRequest$outboundSchema: z.ZodType<
  UpdateInstallationRequest$Outbound,
  z.ZodTypeDef,
  UpdateInstallationRequest
> = z.object({
  projectIdOrName: z.string(),
  integrationId: z.string(),
  installationId: z.string(),
  requestBody: z.lazy(() => UpdateInstallationRequestBody$outboundSchema),
}).transform((v) => {
  return remap$(v, {
    requestBody: "RequestBody",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace UpdateInstallationRequest$ {
  /** @deprecated use `UpdateInstallationRequest$inboundSchema` instead. */
  export const inboundSchema = UpdateInstallationRequest$inboundSchema;
  /** @deprecated use `UpdateInstallationRequest$outboundSchema` instead. */
  export const outboundSchema = UpdateInstallationRequest$outboundSchema;
  /** @deprecated use `UpdateInstallationRequest$Outbound` instead. */
  export type Outbound = UpdateInstallationRequest$Outbound;
}

export function updateInstallationRequestToJSON(
  updateInstallationRequest: UpdateInstallationRequest,
): string {
  return JSON.stringify(
    UpdateInstallationRequest$outboundSchema.parse(updateInstallationRequest),
  );
}

export function updateInstallationRequestFromJSON(
  jsonString: string,
): SafeParseResult<UpdateInstallationRequest, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdateInstallationRequest$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdateInstallationRequest' from JSON`,
  );
}

/** @internal */
export const UpdateInstallationInstallationsResponseBody$inboundSchema:
  z.ZodType<
    UpdateInstallationInstallationsResponseBody,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: z.string().default("about:blank"),
    href: z.string().optional(),
    title: z.string().optional(),
    status: z.number().int().optional(),
    detail: z.string().optional(),
    instance: z.string().optional(),
    subsystem: z.string().optional(),
    time: z.string().datetime({ offset: true }).transform(v => new Date(v))
      .optional(),
    requestId: z.string().optional(),
    causes: z.array(z.string()).optional(),
    remedy: z.string().optional(),
    supportEmail: z.string().optional(),
    supportPhone: z.string().optional(),
    supportUrl: z.string().optional(),
    retryable: z.boolean().optional(),
    retryAfter: z.string().datetime({ offset: true }).transform(v =>
      new Date(v)
    ).optional(),
    context: z.record(z.any()).optional(),
  });

/** @internal */
export type UpdateInstallationInstallationsResponseBody$Outbound = {
  type: string;
  href?: string | undefined;
  title?: string | undefined;
  status?: number | undefined;
  detail?: string | undefined;
  instance?: string | undefined;
  subsystem?: string | undefined;
  time?: string | undefined;
  requestId?: string | undefined;
  causes?: Array<string> | undefined;
  remedy?: string | undefined;
  supportEmail?: string | undefined;
  supportPhone?: string | undefined;
  supportUrl?: string | undefined;
  retryable?: boolean | undefined;
  retryAfter?: string | undefined;
  context?: { [k: string]: any } | undefined;
};

/** @internal */
export const UpdateInstallationInstallationsResponseBody$outboundSchema:
  z.ZodType<
    UpdateInstallationInstallationsResponseBody$Outbound,
    z.ZodTypeDef,
    UpdateInstallationInstallationsResponseBody
  > = z.object({
    type: z.string().default("about:blank"),
    href: z.string().optional(),
    title: z.string().optional(),
    status: z.number().int().optional(),
    detail: z.string().optional(),
    instance: z.string().optional(),
    subsystem: z.string().optional(),
    time: z.date().transform(v => v.toISOString()).optional(),
    requestId: z.string().optional(),
    causes: z.array(z.string()).optional(),
    remedy: z.string().optional(),
    supportEmail: z.string().optional(),
    supportPhone: z.string().optional(),
    supportUrl: z.string().optional(),
    retryable: z.boolean().optional(),
    retryAfter: z.date().transform(v => v.toISOString()).optional(),
    context: z.record(z.any()).optional(),
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace UpdateInstallationInstallationsResponseBody$ {
  /** @deprecated use `UpdateInstallationInstallationsResponseBody$inboundSchema` instead. */
  export const inboundSchema =
    UpdateInstallationInstallationsResponseBody$inboundSchema;
  /** @deprecated use `UpdateInstallationInstallationsResponseBody$outboundSchema` instead. */
  export const outboundSchema =
    UpdateInstallationInstallationsResponseBody$outboundSchema;
  /** @deprecated use `UpdateInstallationInstallationsResponseBody$Outbound` instead. */
  export type Outbound = UpdateInstallationInstallationsResponseBody$Outbound;
}

export function updateInstallationInstallationsResponseBodyToJSON(
  updateInstallationInstallationsResponseBody:
    UpdateInstallationInstallationsResponseBody,
): string {
  return JSON.stringify(
    UpdateInstallationInstallationsResponseBody$outboundSchema.parse(
      updateInstallationInstallationsResponseBody,
    ),
  );
}

export function updateInstallationInstallationsResponseBodyFromJSON(
  jsonString: string,
): SafeParseResult<
  UpdateInstallationInstallationsResponseBody,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      UpdateInstallationInstallationsResponseBody$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'UpdateInstallationInstallationsResponseBody' from JSON`,
  );
}

/** @internal */
export const UpdateInstallationGroup$inboundSchema: z.ZodType<
  UpdateInstallationGroup,
  z.ZodTypeDef,
  unknown
> = z.object({
  groupRef: z.string(),
  groupName: z.string(),
  projectId: z.string(),
  createTime: z.string().datetime({ offset: true }).transform(v => new Date(v)),
  updateTime: z.string().datetime({ offset: true }).transform(v => new Date(v))
    .optional(),
});

/** @internal */
export type UpdateInstallationGroup$Outbound = {
  groupRef: string;
  groupName: string;
  projectId: string;
  createTime: string;
  updateTime?: string | undefined;
};

/** @internal */
export const UpdateInstallationGroup$outboundSchema: z.ZodType<
  UpdateInstallationGroup$Outbound,
  z.ZodTypeDef,
  UpdateInstallationGroup
> = z.object({
  groupRef: z.string(),
  groupName: z.string(),
  projectId: z.string(),
  createTime: z.date().transform(v => v.toISOString()),
  updateTime: z.date().transform(v => v.toISOString()).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace UpdateInstallationGroup$ {
  /** @deprecated use `UpdateInstallationGroup$inboundSchema` instead. */
  export const inboundSchema = UpdateInstallationGroup$inboundSchema;
  /** @deprecated use `UpdateInstallationGroup$outboundSchema` instead. */
  export const outboundSchema = UpdateInstallationGroup$outboundSchema;
  /** @deprecated use `UpdateInstallationGroup$Outbound` instead. */
  export type Outbound = UpdateInstallationGroup$Outbound;
}

export function updateInstallationGroupToJSON(
  updateInstallationGroup: UpdateInstallationGroup,
): string {
  return JSON.stringify(
    UpdateInstallationGroup$outboundSchema.parse(updateInstallationGroup),
  );
}

export function updateInstallationGroupFromJSON(
  jsonString: string,
): SafeParseResult<UpdateInstallationGroup, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdateInstallationGroup$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdateInstallationGroup' from JSON`,
  );
}

/** @internal */
export const UpdateInstallationProviderApp$inboundSchema: z.ZodType<
  UpdateInstallationProviderApp,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  projectId: z.string(),
  externalRef: z.string().optional(),
  provider: z.string(),
  clientId: z.string(),
  scopes: z.array(z.string()).optional(),
  createTime: z.string().datetime({ offset: true }).transform(v => new Date(v)),
  updateTime: z.string().datetime({ offset: true }).transform(v => new Date(v))
    .optional(),
});

/** @internal */
export type UpdateInstallationProviderApp$Outbound = {
  id: string;
  projectId: string;
  externalRef?: string | undefined;
  provider: string;
  clientId: string;
  scopes?: Array<string> | undefined;
  createTime: string;
  updateTime?: string | undefined;
};

/** @internal */
export const UpdateInstallationProviderApp$outboundSchema: z.ZodType<
  UpdateInstallationProviderApp$Outbound,
  z.ZodTypeDef,
  UpdateInstallationProviderApp
> = z.object({
  id: z.string(),
  projectId: z.string(),
  externalRef: z.string().optional(),
  provider: z.string(),
  clientId: z.string(),
  scopes: z.array(z.string()).optional(),
  createTime: z.date().transform(v => v.toISOString()),
  updateTime: z.date().transform(v => v.toISOString()).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace UpdateInstallationProviderApp$ {
  /** @deprecated use `UpdateInstallationProviderApp$inboundSchema` instead. */
  export const inboundSchema = UpdateInstallationProviderApp$inboundSchema;
  /** @deprecated use `UpdateInstallationProviderApp$outboundSchema` instead. */
  export const outboundSchema = UpdateInstallationProviderApp$outboundSchema;
  /** @deprecated use `UpdateInstallationProviderApp$Outbound` instead. */
  export type Outbound = UpdateInstallationProviderApp$Outbound;
}

export function updateInstallationProviderAppToJSON(
  updateInstallationProviderApp: UpdateInstallationProviderApp,
): string {
  return JSON.stringify(
    UpdateInstallationProviderApp$outboundSchema.parse(
      updateInstallationProviderApp,
    ),
  );
}

export function updateInstallationProviderAppFromJSON(
  jsonString: string,
): SafeParseResult<UpdateInstallationProviderApp, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdateInstallationProviderApp$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdateInstallationProviderApp' from JSON`,
  );
}

/** @internal */
export const UpdateInstallationInstallationsGroup$inboundSchema: z.ZodType<
  UpdateInstallationInstallationsGroup,
  z.ZodTypeDef,
  unknown
> = z.object({
  groupRef: z.string(),
  groupName: z.string(),
  projectId: z.string(),
  createTime: z.string().datetime({ offset: true }).transform(v => new Date(v)),
  updateTime: z.string().datetime({ offset: true }).transform(v => new Date(v))
    .optional(),
});

/** @internal */
export type UpdateInstallationInstallationsGroup$Outbound = {
  groupRef: string;
  groupName: string;
  projectId: string;
  createTime: string;
  updateTime?: string | undefined;
};

/** @internal */
export const UpdateInstallationInstallationsGroup$outboundSchema: z.ZodType<
  UpdateInstallationInstallationsGroup$Outbound,
  z.ZodTypeDef,
  UpdateInstallationInstallationsGroup
> = z.object({
  groupRef: z.string(),
  groupName: z.string(),
  projectId: z.string(),
  createTime: z.date().transform(v => v.toISOString()),
  updateTime: z.date().transform(v => v.toISOString()).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace UpdateInstallationInstallationsGroup$ {
  /** @deprecated use `UpdateInstallationInstallationsGroup$inboundSchema` instead. */
  export const inboundSchema =
    UpdateInstallationInstallationsGroup$inboundSchema;
  /** @deprecated use `UpdateInstallationInstallationsGroup$outboundSchema` instead. */
  export const outboundSchema =
    UpdateInstallationInstallationsGroup$outboundSchema;
  /** @deprecated use `UpdateInstallationInstallationsGroup$Outbound` instead. */
  export type Outbound = UpdateInstallationInstallationsGroup$Outbound;
}

export function updateInstallationInstallationsGroupToJSON(
  updateInstallationInstallationsGroup: UpdateInstallationInstallationsGroup,
): string {
  return JSON.stringify(
    UpdateInstallationInstallationsGroup$outboundSchema.parse(
      updateInstallationInstallationsGroup,
    ),
  );
}

export function updateInstallationInstallationsGroupFromJSON(
  jsonString: string,
): SafeParseResult<UpdateInstallationInstallationsGroup, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      UpdateInstallationInstallationsGroup$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdateInstallationInstallationsGroup' from JSON`,
  );
}

/** @internal */
export const UpdateInstallationConsumer$inboundSchema: z.ZodType<
  UpdateInstallationConsumer,
  z.ZodTypeDef,
  unknown
> = z.object({
  consumerRef: z.string(),
  consumerName: z.string(),
  projectId: z.string(),
  createTime: z.string().datetime({ offset: true }).transform(v => new Date(v)),
  updateTime: z.string().datetime({ offset: true }).transform(v => new Date(v))
    .optional(),
});

/** @internal */
export type UpdateInstallationConsumer$Outbound = {
  consumerRef: string;
  consumerName: string;
  projectId: string;
  createTime: string;
  updateTime?: string | undefined;
};

/** @internal */
export const UpdateInstallationConsumer$outboundSchema: z.ZodType<
  UpdateInstallationConsumer$Outbound,
  z.ZodTypeDef,
  UpdateInstallationConsumer
> = z.object({
  consumerRef: z.string(),
  consumerName: z.string(),
  projectId: z.string(),
  createTime: z.date().transform(v => v.toISOString()),
  updateTime: z.date().transform(v => v.toISOString()).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace UpdateInstallationConsumer$ {
  /** @deprecated use `UpdateInstallationConsumer$inboundSchema` instead. */
  export const inboundSchema = UpdateInstallationConsumer$inboundSchema;
  /** @deprecated use `UpdateInstallationConsumer$outboundSchema` instead. */
  export const outboundSchema = UpdateInstallationConsumer$outboundSchema;
  /** @deprecated use `UpdateInstallationConsumer$Outbound` instead. */
  export type Outbound = UpdateInstallationConsumer$Outbound;
}

export function updateInstallationConsumerToJSON(
  updateInstallationConsumer: UpdateInstallationConsumer,
): string {
  return JSON.stringify(
    UpdateInstallationConsumer$outboundSchema.parse(updateInstallationConsumer),
  );
}

export function updateInstallationConsumerFromJSON(
  jsonString: string,
): SafeParseResult<UpdateInstallationConsumer, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdateInstallationConsumer$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdateInstallationConsumer' from JSON`,
  );
}

/** @internal */
export const UpdateInstallationAuthScheme$inboundSchema: z.ZodNativeEnum<
  typeof UpdateInstallationAuthScheme
> = z.nativeEnum(UpdateInstallationAuthScheme);

/** @internal */
export const UpdateInstallationAuthScheme$outboundSchema: z.ZodNativeEnum<
  typeof UpdateInstallationAuthScheme
> = UpdateInstallationAuthScheme$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace UpdateInstallationAuthScheme$ {
  /** @deprecated use `UpdateInstallationAuthScheme$inboundSchema` instead. */
  export const inboundSchema = UpdateInstallationAuthScheme$inboundSchema;
  /** @deprecated use `UpdateInstallationAuthScheme$outboundSchema` instead. */
  export const outboundSchema = UpdateInstallationAuthScheme$outboundSchema;
}

/** @internal */
export const UpdateInstallationStatus$inboundSchema: z.ZodNativeEnum<
  typeof UpdateInstallationStatus
> = z.nativeEnum(UpdateInstallationStatus);

/** @internal */
export const UpdateInstallationStatus$outboundSchema: z.ZodNativeEnum<
  typeof UpdateInstallationStatus
> = UpdateInstallationStatus$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace UpdateInstallationStatus$ {
  /** @deprecated use `UpdateInstallationStatus$inboundSchema` instead. */
  export const inboundSchema = UpdateInstallationStatus$inboundSchema;
  /** @deprecated use `UpdateInstallationStatus$outboundSchema` instead. */
  export const outboundSchema = UpdateInstallationStatus$outboundSchema;
}

/** @internal */
export const UpdateInstallationAccessToken$inboundSchema: z.ZodType<
  UpdateInstallationAccessToken,
  z.ZodTypeDef,
  unknown
> = z.object({
  token: z.string(),
});

/** @internal */
export type UpdateInstallationAccessToken$Outbound = {
  token: string;
};

/** @internal */
export const UpdateInstallationAccessToken$outboundSchema: z.ZodType<
  UpdateInstallationAccessToken$Outbound,
  z.ZodTypeDef,
  UpdateInstallationAccessToken
> = z.object({
  token: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace UpdateInstallationAccessToken$ {
  /** @deprecated use `UpdateInstallationAccessToken$inboundSchema` instead. */
  export const inboundSchema = UpdateInstallationAccessToken$inboundSchema;
  /** @deprecated use `UpdateInstallationAccessToken$outboundSchema` instead. */
  export const outboundSchema = UpdateInstallationAccessToken$outboundSchema;
  /** @deprecated use `UpdateInstallationAccessToken$Outbound` instead. */
  export type Outbound = UpdateInstallationAccessToken$Outbound;
}

export function updateInstallationAccessTokenToJSON(
  updateInstallationAccessToken: UpdateInstallationAccessToken,
): string {
  return JSON.stringify(
    UpdateInstallationAccessToken$outboundSchema.parse(
      updateInstallationAccessToken,
    ),
  );
}

export function updateInstallationAccessTokenFromJSON(
  jsonString: string,
): SafeParseResult<UpdateInstallationAccessToken, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdateInstallationAccessToken$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdateInstallationAccessToken' from JSON`,
  );
}

/** @internal */
export const UpdateInstallationRefreshToken$inboundSchema: z.ZodType<
  UpdateInstallationRefreshToken,
  z.ZodTypeDef,
  unknown
> = z.object({
  token: z.string(),
});

/** @internal */
export type UpdateInstallationRefreshToken$Outbound = {
  token: string;
};

/** @internal */
export const UpdateInstallationRefreshToken$outboundSchema: z.ZodType<
  UpdateInstallationRefreshToken$Outbound,
  z.ZodTypeDef,
  UpdateInstallationRefreshToken
> = z.object({
  token: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace UpdateInstallationRefreshToken$ {
  /** @deprecated use `UpdateInstallationRefreshToken$inboundSchema` instead. */
  export const inboundSchema = UpdateInstallationRefreshToken$inboundSchema;
  /** @deprecated use `UpdateInstallationRefreshToken$outboundSchema` instead. */
  export const outboundSchema = UpdateInstallationRefreshToken$outboundSchema;
  /** @deprecated use `UpdateInstallationRefreshToken$Outbound` instead. */
  export type Outbound = UpdateInstallationRefreshToken$Outbound;
}

export function updateInstallationRefreshTokenToJSON(
  updateInstallationRefreshToken: UpdateInstallationRefreshToken,
): string {
  return JSON.stringify(
    UpdateInstallationRefreshToken$outboundSchema.parse(
      updateInstallationRefreshToken,
    ),
  );
}

export function updateInstallationRefreshTokenFromJSON(
  jsonString: string,
): SafeParseResult<UpdateInstallationRefreshToken, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdateInstallationRefreshToken$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdateInstallationRefreshToken' from JSON`,
  );
}

/** @internal */
export const UpdateInstallationOauth2AuthorizationCode$inboundSchema: z.ZodType<
  UpdateInstallationOauth2AuthorizationCode,
  z.ZodTypeDef,
  unknown
> = z.object({
  accessToken: z.lazy(() => UpdateInstallationAccessToken$inboundSchema)
    .optional(),
  refreshToken: z.lazy(() => UpdateInstallationRefreshToken$inboundSchema)
    .optional(),
  scopes: z.array(z.string()).optional(),
});

/** @internal */
export type UpdateInstallationOauth2AuthorizationCode$Outbound = {
  accessToken?: UpdateInstallationAccessToken$Outbound | undefined;
  refreshToken?: UpdateInstallationRefreshToken$Outbound | undefined;
  scopes?: Array<string> | undefined;
};

/** @internal */
export const UpdateInstallationOauth2AuthorizationCode$outboundSchema:
  z.ZodType<
    UpdateInstallationOauth2AuthorizationCode$Outbound,
    z.ZodTypeDef,
    UpdateInstallationOauth2AuthorizationCode
  > = z.object({
    accessToken: z.lazy(() => UpdateInstallationAccessToken$outboundSchema)
      .optional(),
    refreshToken: z.lazy(() => UpdateInstallationRefreshToken$outboundSchema)
      .optional(),
    scopes: z.array(z.string()).optional(),
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace UpdateInstallationOauth2AuthorizationCode$ {
  /** @deprecated use `UpdateInstallationOauth2AuthorizationCode$inboundSchema` instead. */
  export const inboundSchema =
    UpdateInstallationOauth2AuthorizationCode$inboundSchema;
  /** @deprecated use `UpdateInstallationOauth2AuthorizationCode$outboundSchema` instead. */
  export const outboundSchema =
    UpdateInstallationOauth2AuthorizationCode$outboundSchema;
  /** @deprecated use `UpdateInstallationOauth2AuthorizationCode$Outbound` instead. */
  export type Outbound = UpdateInstallationOauth2AuthorizationCode$Outbound;
}

export function updateInstallationOauth2AuthorizationCodeToJSON(
  updateInstallationOauth2AuthorizationCode:
    UpdateInstallationOauth2AuthorizationCode,
): string {
  return JSON.stringify(
    UpdateInstallationOauth2AuthorizationCode$outboundSchema.parse(
      updateInstallationOauth2AuthorizationCode,
    ),
  );
}

export function updateInstallationOauth2AuthorizationCodeFromJSON(
  jsonString: string,
): SafeParseResult<
  UpdateInstallationOauth2AuthorizationCode,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      UpdateInstallationOauth2AuthorizationCode$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'UpdateInstallationOauth2AuthorizationCode' from JSON`,
  );
}

/** @internal */
export const UpdateInstallationConnection$inboundSchema: z.ZodType<
  UpdateInstallationConnection,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  projectId: z.string(),
  provider: z.string(),
  providerApp: z.lazy(() => UpdateInstallationProviderApp$inboundSchema)
    .optional(),
  group: z.lazy(() => UpdateInstallationInstallationsGroup$inboundSchema),
  consumer: z.lazy(() => UpdateInstallationConsumer$inboundSchema),
  providerWorkspaceRef: z.string().optional(),
  providerConsumerRef: z.string().optional(),
  createTime: z.string().datetime({ offset: true }).transform(v => new Date(v)),
  updateTime: z.string().datetime({ offset: true }).transform(v => new Date(v))
    .optional(),
  authScheme: UpdateInstallationAuthScheme$inboundSchema,
  status: UpdateInstallationStatus$inboundSchema,
  oauth2AuthorizationCode: z.lazy(() =>
    UpdateInstallationOauth2AuthorizationCode$inboundSchema
  ).optional(),
  apiKey: z.string().optional(),
});

/** @internal */
export type UpdateInstallationConnection$Outbound = {
  id: string;
  projectId: string;
  provider: string;
  providerApp?: UpdateInstallationProviderApp$Outbound | undefined;
  group: UpdateInstallationInstallationsGroup$Outbound;
  consumer: UpdateInstallationConsumer$Outbound;
  providerWorkspaceRef?: string | undefined;
  providerConsumerRef?: string | undefined;
  createTime: string;
  updateTime?: string | undefined;
  authScheme: string;
  status: string;
  oauth2AuthorizationCode?:
    | UpdateInstallationOauth2AuthorizationCode$Outbound
    | undefined;
  apiKey?: string | undefined;
};

/** @internal */
export const UpdateInstallationConnection$outboundSchema: z.ZodType<
  UpdateInstallationConnection$Outbound,
  z.ZodTypeDef,
  UpdateInstallationConnection
> = z.object({
  id: z.string(),
  projectId: z.string(),
  provider: z.string(),
  providerApp: z.lazy(() => UpdateInstallationProviderApp$outboundSchema)
    .optional(),
  group: z.lazy(() => UpdateInstallationInstallationsGroup$outboundSchema),
  consumer: z.lazy(() => UpdateInstallationConsumer$outboundSchema),
  providerWorkspaceRef: z.string().optional(),
  providerConsumerRef: z.string().optional(),
  createTime: z.date().transform(v => v.toISOString()),
  updateTime: z.date().transform(v => v.toISOString()).optional(),
  authScheme: UpdateInstallationAuthScheme$outboundSchema,
  status: UpdateInstallationStatus$outboundSchema,
  oauth2AuthorizationCode: z.lazy(() =>
    UpdateInstallationOauth2AuthorizationCode$outboundSchema
  ).optional(),
  apiKey: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace UpdateInstallationConnection$ {
  /** @deprecated use `UpdateInstallationConnection$inboundSchema` instead. */
  export const inboundSchema = UpdateInstallationConnection$inboundSchema;
  /** @deprecated use `UpdateInstallationConnection$outboundSchema` instead. */
  export const outboundSchema = UpdateInstallationConnection$outboundSchema;
  /** @deprecated use `UpdateInstallationConnection$Outbound` instead. */
  export type Outbound = UpdateInstallationConnection$Outbound;
}

export function updateInstallationConnectionToJSON(
  updateInstallationConnection: UpdateInstallationConnection,
): string {
  return JSON.stringify(
    UpdateInstallationConnection$outboundSchema.parse(
      updateInstallationConnection,
    ),
  );
}

export function updateInstallationConnectionFromJSON(
  jsonString: string,
): SafeParseResult<UpdateInstallationConnection, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdateInstallationConnection$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdateInstallationConnection' from JSON`,
  );
}

/** @internal */
export const UpdateInstallationInstallationsProxy$inboundSchema: z.ZodType<
  UpdateInstallationInstallationsProxy,
  z.ZodTypeDef,
  unknown
> = z.object({
  enabled: z.boolean().optional(),
});

/** @internal */
export type UpdateInstallationInstallationsProxy$Outbound = {
  enabled?: boolean | undefined;
};

/** @internal */
export const UpdateInstallationInstallationsProxy$outboundSchema: z.ZodType<
  UpdateInstallationInstallationsProxy$Outbound,
  z.ZodTypeDef,
  UpdateInstallationInstallationsProxy
> = z.object({
  enabled: z.boolean().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace UpdateInstallationInstallationsProxy$ {
  /** @deprecated use `UpdateInstallationInstallationsProxy$inboundSchema` instead. */
  export const inboundSchema =
    UpdateInstallationInstallationsProxy$inboundSchema;
  /** @deprecated use `UpdateInstallationInstallationsProxy$outboundSchema` instead. */
  export const outboundSchema =
    UpdateInstallationInstallationsProxy$outboundSchema;
  /** @deprecated use `UpdateInstallationInstallationsProxy$Outbound` instead. */
  export type Outbound = UpdateInstallationInstallationsProxy$Outbound;
}

export function updateInstallationInstallationsProxyToJSON(
  updateInstallationInstallationsProxy: UpdateInstallationInstallationsProxy,
): string {
  return JSON.stringify(
    UpdateInstallationInstallationsProxy$outboundSchema.parse(
      updateInstallationInstallationsProxy,
    ),
  );
}

export function updateInstallationInstallationsProxyFromJSON(
  jsonString: string,
): SafeParseResult<UpdateInstallationInstallationsProxy, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      UpdateInstallationInstallationsProxy$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdateInstallationInstallationsProxy' from JSON`,
  );
}

/** @internal */
export const UpdateInstallationInstallationsContent$inboundSchema: z.ZodType<
  UpdateInstallationInstallationsContent,
  z.ZodTypeDef,
  unknown
> = z.object({
  provider: z.string(),
  read: z.any().optional(),
  write: z.any().optional(),
  proxy: z.lazy(() => UpdateInstallationInstallationsProxy$inboundSchema)
    .optional(),
});

/** @internal */
export type UpdateInstallationInstallationsContent$Outbound = {
  provider: string;
  read?: any | undefined;
  write?: any | undefined;
  proxy?: UpdateInstallationInstallationsProxy$Outbound | undefined;
};

/** @internal */
export const UpdateInstallationInstallationsContent$outboundSchema: z.ZodType<
  UpdateInstallationInstallationsContent$Outbound,
  z.ZodTypeDef,
  UpdateInstallationInstallationsContent
> = z.object({
  provider: z.string(),
  read: z.any().optional(),
  write: z.any().optional(),
  proxy: z.lazy(() => UpdateInstallationInstallationsProxy$outboundSchema)
    .optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace UpdateInstallationInstallationsContent$ {
  /** @deprecated use `UpdateInstallationInstallationsContent$inboundSchema` instead. */
  export const inboundSchema =
    UpdateInstallationInstallationsContent$inboundSchema;
  /** @deprecated use `UpdateInstallationInstallationsContent$outboundSchema` instead. */
  export const outboundSchema =
    UpdateInstallationInstallationsContent$outboundSchema;
  /** @deprecated use `UpdateInstallationInstallationsContent$Outbound` instead. */
  export type Outbound = UpdateInstallationInstallationsContent$Outbound;
}

export function updateInstallationInstallationsContentToJSON(
  updateInstallationInstallationsContent:
    UpdateInstallationInstallationsContent,
): string {
  return JSON.stringify(
    UpdateInstallationInstallationsContent$outboundSchema.parse(
      updateInstallationInstallationsContent,
    ),
  );
}

export function updateInstallationInstallationsContentFromJSON(
  jsonString: string,
): SafeParseResult<UpdateInstallationInstallationsContent, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      UpdateInstallationInstallationsContent$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdateInstallationInstallationsContent' from JSON`,
  );
}

/** @internal */
export const UpdateInstallationInstallationsConfig$inboundSchema: z.ZodType<
  UpdateInstallationInstallationsConfig,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  revisionId: z.string(),
  createTime: z.string().datetime({ offset: true }).transform(v => new Date(v)),
  createdBy: z.string(),
  content: z.lazy(() => UpdateInstallationInstallationsContent$inboundSchema),
});

/** @internal */
export type UpdateInstallationInstallationsConfig$Outbound = {
  id: string;
  revisionId: string;
  createTime: string;
  createdBy: string;
  content: UpdateInstallationInstallationsContent$Outbound;
};

/** @internal */
export const UpdateInstallationInstallationsConfig$outboundSchema: z.ZodType<
  UpdateInstallationInstallationsConfig$Outbound,
  z.ZodTypeDef,
  UpdateInstallationInstallationsConfig
> = z.object({
  id: z.string(),
  revisionId: z.string(),
  createTime: z.date().transform(v => v.toISOString()),
  createdBy: z.string(),
  content: z.lazy(() => UpdateInstallationInstallationsContent$outboundSchema),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace UpdateInstallationInstallationsConfig$ {
  /** @deprecated use `UpdateInstallationInstallationsConfig$inboundSchema` instead. */
  export const inboundSchema =
    UpdateInstallationInstallationsConfig$inboundSchema;
  /** @deprecated use `UpdateInstallationInstallationsConfig$outboundSchema` instead. */
  export const outboundSchema =
    UpdateInstallationInstallationsConfig$outboundSchema;
  /** @deprecated use `UpdateInstallationInstallationsConfig$Outbound` instead. */
  export type Outbound = UpdateInstallationInstallationsConfig$Outbound;
}

export function updateInstallationInstallationsConfigToJSON(
  updateInstallationInstallationsConfig: UpdateInstallationInstallationsConfig,
): string {
  return JSON.stringify(
    UpdateInstallationInstallationsConfig$outboundSchema.parse(
      updateInstallationInstallationsConfig,
    ),
  );
}

export function updateInstallationInstallationsConfigFromJSON(
  jsonString: string,
): SafeParseResult<UpdateInstallationInstallationsConfig, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      UpdateInstallationInstallationsConfig$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdateInstallationInstallationsConfig' from JSON`,
  );
}

/** @internal */
export const UpdateInstallationResponseBody$inboundSchema: z.ZodType<
  UpdateInstallationResponseBody,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  projectId: z.string(),
  integrationId: z.string(),
  group: z.lazy(() => UpdateInstallationGroup$inboundSchema).optional(),
  healthStatus: z.string(),
  connection: z.lazy(() => UpdateInstallationConnection$inboundSchema),
  createTime: z.string().datetime({ offset: true }).transform(v => new Date(v)),
  createdBy: z.string(),
  updateTime: z.string().datetime({ offset: true }).transform(v => new Date(v))
    .optional(),
  config: z.lazy(() => UpdateInstallationInstallationsConfig$inboundSchema),
});

/** @internal */
export type UpdateInstallationResponseBody$Outbound = {
  id: string;
  projectId: string;
  integrationId: string;
  group?: UpdateInstallationGroup$Outbound | undefined;
  healthStatus: string;
  connection: UpdateInstallationConnection$Outbound;
  createTime: string;
  createdBy: string;
  updateTime?: string | undefined;
  config: UpdateInstallationInstallationsConfig$Outbound;
};

/** @internal */
export const UpdateInstallationResponseBody$outboundSchema: z.ZodType<
  UpdateInstallationResponseBody$Outbound,
  z.ZodTypeDef,
  UpdateInstallationResponseBody
> = z.object({
  id: z.string(),
  projectId: z.string(),
  integrationId: z.string(),
  group: z.lazy(() => UpdateInstallationGroup$outboundSchema).optional(),
  healthStatus: z.string(),
  connection: z.lazy(() => UpdateInstallationConnection$outboundSchema),
  createTime: z.date().transform(v => v.toISOString()),
  createdBy: z.string(),
  updateTime: z.date().transform(v => v.toISOString()).optional(),
  config: z.lazy(() => UpdateInstallationInstallationsConfig$outboundSchema),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace UpdateInstallationResponseBody$ {
  /** @deprecated use `UpdateInstallationResponseBody$inboundSchema` instead. */
  export const inboundSchema = UpdateInstallationResponseBody$inboundSchema;
  /** @deprecated use `UpdateInstallationResponseBody$outboundSchema` instead. */
  export const outboundSchema = UpdateInstallationResponseBody$outboundSchema;
  /** @deprecated use `UpdateInstallationResponseBody$Outbound` instead. */
  export type Outbound = UpdateInstallationResponseBody$Outbound;
}

export function updateInstallationResponseBodyToJSON(
  updateInstallationResponseBody: UpdateInstallationResponseBody,
): string {
  return JSON.stringify(
    UpdateInstallationResponseBody$outboundSchema.parse(
      updateInstallationResponseBody,
    ),
  );
}

export function updateInstallationResponseBodyFromJSON(
  jsonString: string,
): SafeParseResult<UpdateInstallationResponseBody, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdateInstallationResponseBody$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdateInstallationResponseBody' from JSON`,
  );
}

/** @internal */
export const UpdateInstallationResponse$inboundSchema: z.ZodType<
  UpdateInstallationResponse,
  z.ZodTypeDef,
  unknown
> = z.union([
  z.lazy(() => UpdateInstallationResponseBody$inboundSchema),
  z.lazy(() => UpdateInstallationInstallationsResponseBody$inboundSchema),
]);

/** @internal */
export type UpdateInstallationResponse$Outbound =
  | UpdateInstallationResponseBody$Outbound
  | UpdateInstallationInstallationsResponseBody$Outbound;

/** @internal */
export const UpdateInstallationResponse$outboundSchema: z.ZodType<
  UpdateInstallationResponse$Outbound,
  z.ZodTypeDef,
  UpdateInstallationResponse
> = z.union([
  z.lazy(() => UpdateInstallationResponseBody$outboundSchema),
  z.lazy(() => UpdateInstallationInstallationsResponseBody$outboundSchema),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace UpdateInstallationResponse$ {
  /** @deprecated use `UpdateInstallationResponse$inboundSchema` instead. */
  export const inboundSchema = UpdateInstallationResponse$inboundSchema;
  /** @deprecated use `UpdateInstallationResponse$outboundSchema` instead. */
  export const outboundSchema = UpdateInstallationResponse$outboundSchema;
  /** @deprecated use `UpdateInstallationResponse$Outbound` instead. */
  export type Outbound = UpdateInstallationResponse$Outbound;
}

export function updateInstallationResponseToJSON(
  updateInstallationResponse: UpdateInstallationResponse,
): string {
  return JSON.stringify(
    UpdateInstallationResponse$outboundSchema.parse(updateInstallationResponse),
  );
}

export function updateInstallationResponseFromJSON(
  jsonString: string,
): SafeParseResult<UpdateInstallationResponse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdateInstallationResponse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdateInstallationResponse' from JSON`,
  );
}
