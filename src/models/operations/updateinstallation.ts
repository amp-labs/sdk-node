/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod";
import { remap as remap$ } from "../../lib/primitives.js";
import { safeParse } from "../../lib/schemas.js";
import { ClosedEnum } from "../../types/enums.js";
import { Result as SafeParseResult } from "../../types/fp.js";
import { SDKValidationError } from "../errors/sdkvalidationerror.js";

export const UpdateInstallationServerList = [
  "https://api.withampersand.com/v1",
] as const;

/**
 * If selectedFieldsAuto is set to all, all fields will be read.
 */
export const SelectedFieldsAuto = {
  All: "all",
} as const;
/**
 * If selectedFieldsAuto is set to all, all fields will be read.
 */
export type SelectedFieldsAuto = ClosedEnum<typeof SelectedFieldsAuto>;

export type UpdateInstallationDefaultPeriod = {
  /**
   * Number of days in past to backfill from. 0 is no backfill. e.g) if 10, then backfill last 10 days of data. Required if fullHistory is not set.
   */
  days?: number | undefined;
  /**
   * If true, backfill all history. Required if days is not set.
   */
  fullHistory?: boolean | undefined;
};

export type UpdateInstallationBackfill = {
  defaultPeriod: UpdateInstallationDefaultPeriod;
};

export type UpdateInstallationObjects = {
  /**
   * The name of the object to read from.
   */
  objectName?: string | undefined;
  /**
   * The schedule for reading the object, in cron syntax.
   */
  schedule?: string | undefined;
  /**
   * The name of the destination that the result should be sent to.
   */
  destination?: string | undefined;
  /**
   * This is a map of field names to booleans indicating whether they should be read. If a field is already included in `selectedFieldMappings`, it does not need to be included here.
   */
  selectedFields?: { [k: string]: boolean } | undefined;
  /**
   * This is a map of field names to their value mappings.
   */
  selectedValueMappings?: { [k: string]: { [k: string]: string } } | undefined;
  /**
   * This is a map of mapToNames to field names. (A mapTo name is the name the builder wants to map a field to when it lands in their destination.)
   */
  selectedFieldMappings?: { [k: string]: string } | undefined;
  /**
   * If selectedFieldsAuto is set to all, all fields will be read.
   */
  selectedFieldsAuto?: SelectedFieldsAuto | undefined;
  backfill?: UpdateInstallationBackfill | undefined;
};

export type UpdateInstallationRead = {
  /**
   * This is a map of object names to their configuration.
   */
  objects?: { [k: string]: UpdateInstallationObjects } | undefined;
};

export type UpdateInstallationInstallationObjects = {
  /**
   * The name of the object to write to.
   */
  objectName?: string | undefined;
  /**
   * This is a map of field names to default values. These values will be used when writing to the object.
   */
  selectedValueDefaults?: { [k: string]: string } | undefined;
};

export type UpdateInstallationWrite = {
  /**
   * This is a map of object names to their configuration.
   */
  objects?: { [k: string]: UpdateInstallationInstallationObjects } | undefined;
};

export type UpdateInstallationProxy = {
  enabled?: boolean | undefined;
};

export type UpdateInstallationContent = {
  /**
   * The SaaS API that we are integrating with.
   */
  provider?: string | undefined;
  read?: UpdateInstallationRead | undefined;
  write?: UpdateInstallationWrite | undefined;
  proxy?: UpdateInstallationProxy | undefined;
};

/**
 * The config of the installation.
 */
export type UpdateInstallationConfig = {
  /**
   * The ID of the revision that this config is based on.
   */
  revisionId?: string | undefined;
  /**
   * The person who created the config, in the format of "consumer:{consumer-id}" or "builder:{builder-id}".
   */
  createdBy?: string | undefined;
  /**
   * The content of the config.
   */
  content?: UpdateInstallationContent | undefined;
};

/**
 * The installation fields to update. (Only include the fields you'd like to update.)
 */
export type Installation = {
  /**
   * The ID of the SaaS connection tied to this installation.
   */
  connectionId?: string | undefined;
  /**
   * The config of the installation.
   */
  config?: UpdateInstallationConfig | undefined;
};

export type UpdateInstallationRequestBody = {
  updateMask: Array<string>;
  /**
   * The installation fields to update. (Only include the fields you'd like to update.)
   */
  installation: Installation;
};

export type UpdateInstallationRequest = {
  projectIdOrName: string;
  integrationId: string;
  installationId: string;
  requestBody: UpdateInstallationRequestBody;
};

/**
 * A Problem Details object (RFC 9457).
 *
 * @remarks
 *
 * Additional properties specific to the problem type may be present.
 */
export type UpdateInstallationInstallationResponseBody = {
  /**
   * An absolute URI that identifies the problem type
   */
  type?: string | undefined;
  /**
   * An absolute URI that, when dereferenced, provides human-readable documentation for the problem type (e.g. using HTML).
   */
  href?: string | undefined;
  /**
   * A short summary of the problem type. Written in English and readable for engineers (usually not suited for non technical stakeholders and not localized).
   */
  title?: string | undefined;
  /**
   * The HTTP status code generated by the origin server for this occurrence of the problem.
   */
  status?: number | undefined;
  /**
   * A human-readable explanation specific to this occurrence of the problem
   */
  detail?: string | undefined;
  /**
   * An absolute URI that identifies the specific occurrence of the problem. It may or may not yield further information if dereferenced.
   */
  instance?: string | undefined;
  /**
   * The subsystem that generated the problem
   */
  subsystem?: string | undefined;
  /**
   * The time the problem occurred, formatted as RFC-3339
   */
  time?: Date | undefined;
  /**
   * A unique identifier for the request, useful for debugging
   */
  requestId?: string | undefined;
  /**
   * A list of problems that caused this problem. This can be used to represent multiple
   *
   * @remarks
   * root causes. There is no guaranteed ordering of the causes.
   */
  causes?: Array<string> | undefined;
  /**
   * A brief description of how to resolve the problem
   */
  remedy?: string | undefined;
  /**
   * An email address to contact for support
   */
  supportEmail?: string | undefined;
  /**
   * A phone number to contact for support
   */
  supportPhone?: string | undefined;
  /**
   * A URL to contact for support
   */
  supportUrl?: string | undefined;
  /**
   * Whether the request can be retried
   */
  retryable?: boolean | undefined;
  /**
   * A timestamp after which the request can be retried, formatted as RFC-3339
   */
  retryAfter?: Date | undefined;
  /**
   * Additional context for the problem
   */
  context?: { [k: string]: any } | undefined;
};

export type UpdateInstallationGroup = {
  /**
   * The ID of the user group that has access to this installation.
   */
  groupRef: string;
  /**
   * The name of the user group that has access to this installation.
   */
  groupName: string;
  /**
   * The Ampersand project ID.
   */
  projectId: string;
  /**
   * The time the group was created.
   */
  createTime: Date;
  /**
   * The time the group was last updated.
   */
  updateTime?: Date | undefined;
};

export type UpdateInstallationProviderApp = {
  /**
   * The provider app ID.
   */
  id: string;
  /**
   * The Ampersand project ID.
   */
  projectId: string;
  /**
   * The ID used by the provider to identify the app (optional).
   */
  externalRef?: string | undefined;
  /**
   * The SaaS provider that this app connects to.
   */
  provider: string;
  /**
   * The OAuth client ID for this app.
   */
  clientId: string;
  /**
   * The OAuth scopes for this app.
   */
  scopes?: Array<string> | undefined;
  /**
   * The time the provider app was created.
   */
  createTime: Date;
  /**
   * The time the provider app was updated.
   */
  updateTime?: Date | undefined;
};

export type UpdateInstallationInstallationGroup = {
  /**
   * The ID of the user group that has access to this installation.
   */
  groupRef: string;
  /**
   * The name of the user group that has access to this installation.
   */
  groupName: string;
  /**
   * The Ampersand project ID.
   */
  projectId: string;
  /**
   * The time the group was created.
   */
  createTime: Date;
  /**
   * The time the group was last updated.
   */
  updateTime?: Date | undefined;
};

export type UpdateInstallationConsumer = {
  /**
   * The consumer reference.
   */
  consumerRef: string;
  /**
   * The name of the consumer.
   */
  consumerName: string;
  /**
   * The Ampersand project ID.
   */
  projectId: string;
  /**
   * The time the consumer was created.
   */
  createTime: Date;
  /**
   * The time the consumer was last updated.
   */
  updateTime?: Date | undefined;
};

/**
 * The authentication scheme used for this connection.
 */
export const UpdateInstallationAuthScheme = {
  None: "none",
  ApiKey: "apiKey",
  Basic: "basic",
  Oauth2AuthorizationCode: "oauth2/authorizationCode",
  Oauth2AuthorizationCodePKCE: "oauth2/authorizationCodePKCE",
  Oauth2ClientCredentials: "oauth2/clientCredentials",
  Oauth2Password: "oauth2/password",
} as const;
/**
 * The authentication scheme used for this connection.
 */
export type UpdateInstallationAuthScheme = ClosedEnum<
  typeof UpdateInstallationAuthScheme
>;

/**
 * The status of the connection.
 */
export const UpdateInstallationStatus = {
  Created: "created",
  Working: "working",
  BadCredentials: "bad_credentials",
} as const;
/**
 * The status of the connection.
 */
export type UpdateInstallationStatus = ClosedEnum<
  typeof UpdateInstallationStatus
>;

/**
 * The access token for the connection.
 */
export type UpdateInstallationAccessToken = {
  token: string;
};

/**
 * The refresh token to use for the connection.
 */
export type UpdateInstallationRefreshToken = {
  token: string;
};

export type UpdateInstallationOauth2AuthorizationCode = {
  /**
   * The access token for the connection.
   */
  accessToken?: UpdateInstallationAccessToken | undefined;
  /**
   * The refresh token to use for the connection.
   */
  refreshToken?: UpdateInstallationRefreshToken | undefined;
  /**
   * The scopes for the tokens.
   */
  scopes?: Array<string> | undefined;
};

export type UpdateInstallationConnection = {
  /**
   * The connection ID.
   */
  id: string;
  /**
   * The Ampersand project ID.
   */
  projectId: string;
  /**
   * The SaaS provider that this Connection is for.
   */
  provider: string;
  providerApp?: UpdateInstallationProviderApp | undefined;
  group: UpdateInstallationInstallationGroup;
  consumer: UpdateInstallationConsumer;
  /**
   * If available, the identifier for the provider workspace (e.g. "salesforce-instance-domain")
   */
  providerWorkspaceRef?: string | undefined;
  /**
   * If available, the ID that Salesforce/Hubspot uses to identify this user (e.g. Salesforce has IDs in the form of https://login.salesforce.com/id/00D4x0000019CQTEA2/0054x000000orJ4AA)
   */
  providerConsumerRef?: string | undefined;
  /**
   * The time the connection was created.
   */
  createTime: Date;
  /**
   * The time the connection was last updated.
   */
  updateTime?: Date | undefined;
  /**
   * The authentication scheme used for this connection.
   */
  authScheme: UpdateInstallationAuthScheme;
  /**
   * The status of the connection.
   */
  status: UpdateInstallationStatus;
  oauth2AuthorizationCode?:
    | UpdateInstallationOauth2AuthorizationCode
    | undefined;
};

export type UpdateInstallationInstallationProxy = {
  enabled?: boolean | undefined;
};

export type UpdateInstallationInstallationContent = {
  /**
   * The SaaS API that we are integrating with.
   */
  provider: string;
  read?: any | undefined;
  write?: any | undefined;
  proxy?: UpdateInstallationInstallationProxy | undefined;
};

export type UpdateInstallationInstallationConfig = {
  /**
   * The config ID.
   */
  id: string;
  /**
   * The ID of the revision that this config is based on.
   */
  revisionId: string;
  /**
   * The time the config was created.
   */
  createTime: Date;
  /**
   * The person who created the config, in the format of "consumer:{consumer-id}" or "builder:{builder-id}".
   */
  createdBy: string;
  content: UpdateInstallationInstallationContent;
};

/**
 * The updated installation
 */
export type UpdateInstallationResponseBody = {
  /**
   * The installation ID.
   */
  id: string;
  /**
   * The Ampersand project ID.
   */
  projectId: string;
  /**
   * The integration ID.
   */
  integrationId: string;
  group?: UpdateInstallationGroup | undefined;
  /**
   * The health status of the installation ("healthy", "unhealthy").
   */
  healthStatus: string;
  connection: UpdateInstallationConnection;
  /**
   * The time the integration was first installed.
   */
  createTime: Date;
  /**
   * The person who did the installation, in the format of "consumer:{consumer-id}".
   */
  createdBy: string;
  /**
   * The time the installation was last updated with a new config.
   */
  updateTime?: Date | undefined;
  config: UpdateInstallationInstallationConfig;
};

export type UpdateInstallationResponse =
  | UpdateInstallationResponseBody
  | UpdateInstallationInstallationResponseBody;

/** @internal */
export const SelectedFieldsAuto$inboundSchema: z.ZodNativeEnum<
  typeof SelectedFieldsAuto
> = z.nativeEnum(SelectedFieldsAuto);

/** @internal */
export const SelectedFieldsAuto$outboundSchema: z.ZodNativeEnum<
  typeof SelectedFieldsAuto
> = SelectedFieldsAuto$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace SelectedFieldsAuto$ {
  /** @deprecated use `SelectedFieldsAuto$inboundSchema` instead. */
  export const inboundSchema = SelectedFieldsAuto$inboundSchema;
  /** @deprecated use `SelectedFieldsAuto$outboundSchema` instead. */
  export const outboundSchema = SelectedFieldsAuto$outboundSchema;
}

/** @internal */
export const UpdateInstallationDefaultPeriod$inboundSchema: z.ZodType<
  UpdateInstallationDefaultPeriod,
  z.ZodTypeDef,
  unknown
> = z.object({
  days: z.number().int().optional(),
  fullHistory: z.boolean().optional(),
});

/** @internal */
export type UpdateInstallationDefaultPeriod$Outbound = {
  days?: number | undefined;
  fullHistory?: boolean | undefined;
};

/** @internal */
export const UpdateInstallationDefaultPeriod$outboundSchema: z.ZodType<
  UpdateInstallationDefaultPeriod$Outbound,
  z.ZodTypeDef,
  UpdateInstallationDefaultPeriod
> = z.object({
  days: z.number().int().optional(),
  fullHistory: z.boolean().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace UpdateInstallationDefaultPeriod$ {
  /** @deprecated use `UpdateInstallationDefaultPeriod$inboundSchema` instead. */
  export const inboundSchema = UpdateInstallationDefaultPeriod$inboundSchema;
  /** @deprecated use `UpdateInstallationDefaultPeriod$outboundSchema` instead. */
  export const outboundSchema = UpdateInstallationDefaultPeriod$outboundSchema;
  /** @deprecated use `UpdateInstallationDefaultPeriod$Outbound` instead. */
  export type Outbound = UpdateInstallationDefaultPeriod$Outbound;
}

export function updateInstallationDefaultPeriodToJSON(
  updateInstallationDefaultPeriod: UpdateInstallationDefaultPeriod,
): string {
  return JSON.stringify(
    UpdateInstallationDefaultPeriod$outboundSchema.parse(
      updateInstallationDefaultPeriod,
    ),
  );
}

export function updateInstallationDefaultPeriodFromJSON(
  jsonString: string,
): SafeParseResult<UpdateInstallationDefaultPeriod, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdateInstallationDefaultPeriod$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdateInstallationDefaultPeriod' from JSON`,
  );
}

/** @internal */
export const UpdateInstallationBackfill$inboundSchema: z.ZodType<
  UpdateInstallationBackfill,
  z.ZodTypeDef,
  unknown
> = z.object({
  defaultPeriod: z.lazy(() => UpdateInstallationDefaultPeriod$inboundSchema),
});

/** @internal */
export type UpdateInstallationBackfill$Outbound = {
  defaultPeriod: UpdateInstallationDefaultPeriod$Outbound;
};

/** @internal */
export const UpdateInstallationBackfill$outboundSchema: z.ZodType<
  UpdateInstallationBackfill$Outbound,
  z.ZodTypeDef,
  UpdateInstallationBackfill
> = z.object({
  defaultPeriod: z.lazy(() => UpdateInstallationDefaultPeriod$outboundSchema),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace UpdateInstallationBackfill$ {
  /** @deprecated use `UpdateInstallationBackfill$inboundSchema` instead. */
  export const inboundSchema = UpdateInstallationBackfill$inboundSchema;
  /** @deprecated use `UpdateInstallationBackfill$outboundSchema` instead. */
  export const outboundSchema = UpdateInstallationBackfill$outboundSchema;
  /** @deprecated use `UpdateInstallationBackfill$Outbound` instead. */
  export type Outbound = UpdateInstallationBackfill$Outbound;
}

export function updateInstallationBackfillToJSON(
  updateInstallationBackfill: UpdateInstallationBackfill,
): string {
  return JSON.stringify(
    UpdateInstallationBackfill$outboundSchema.parse(updateInstallationBackfill),
  );
}

export function updateInstallationBackfillFromJSON(
  jsonString: string,
): SafeParseResult<UpdateInstallationBackfill, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdateInstallationBackfill$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdateInstallationBackfill' from JSON`,
  );
}

/** @internal */
export const UpdateInstallationObjects$inboundSchema: z.ZodType<
  UpdateInstallationObjects,
  z.ZodTypeDef,
  unknown
> = z.object({
  objectName: z.string().optional(),
  schedule: z.string().optional(),
  destination: z.string().optional(),
  selectedFields: z.record(z.boolean()).optional(),
  selectedValueMappings: z.record(z.record(z.string())).optional(),
  selectedFieldMappings: z.record(z.string()).optional(),
  selectedFieldsAuto: SelectedFieldsAuto$inboundSchema.optional(),
  backfill: z.lazy(() => UpdateInstallationBackfill$inboundSchema).optional(),
});

/** @internal */
export type UpdateInstallationObjects$Outbound = {
  objectName?: string | undefined;
  schedule?: string | undefined;
  destination?: string | undefined;
  selectedFields?: { [k: string]: boolean } | undefined;
  selectedValueMappings?: { [k: string]: { [k: string]: string } } | undefined;
  selectedFieldMappings?: { [k: string]: string } | undefined;
  selectedFieldsAuto?: string | undefined;
  backfill?: UpdateInstallationBackfill$Outbound | undefined;
};

/** @internal */
export const UpdateInstallationObjects$outboundSchema: z.ZodType<
  UpdateInstallationObjects$Outbound,
  z.ZodTypeDef,
  UpdateInstallationObjects
> = z.object({
  objectName: z.string().optional(),
  schedule: z.string().optional(),
  destination: z.string().optional(),
  selectedFields: z.record(z.boolean()).optional(),
  selectedValueMappings: z.record(z.record(z.string())).optional(),
  selectedFieldMappings: z.record(z.string()).optional(),
  selectedFieldsAuto: SelectedFieldsAuto$outboundSchema.optional(),
  backfill: z.lazy(() => UpdateInstallationBackfill$outboundSchema).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace UpdateInstallationObjects$ {
  /** @deprecated use `UpdateInstallationObjects$inboundSchema` instead. */
  export const inboundSchema = UpdateInstallationObjects$inboundSchema;
  /** @deprecated use `UpdateInstallationObjects$outboundSchema` instead. */
  export const outboundSchema = UpdateInstallationObjects$outboundSchema;
  /** @deprecated use `UpdateInstallationObjects$Outbound` instead. */
  export type Outbound = UpdateInstallationObjects$Outbound;
}

export function updateInstallationObjectsToJSON(
  updateInstallationObjects: UpdateInstallationObjects,
): string {
  return JSON.stringify(
    UpdateInstallationObjects$outboundSchema.parse(updateInstallationObjects),
  );
}

export function updateInstallationObjectsFromJSON(
  jsonString: string,
): SafeParseResult<UpdateInstallationObjects, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdateInstallationObjects$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdateInstallationObjects' from JSON`,
  );
}

/** @internal */
export const UpdateInstallationRead$inboundSchema: z.ZodType<
  UpdateInstallationRead,
  z.ZodTypeDef,
  unknown
> = z.object({
  objects: z.record(z.lazy(() => UpdateInstallationObjects$inboundSchema))
    .optional(),
});

/** @internal */
export type UpdateInstallationRead$Outbound = {
  objects?: { [k: string]: UpdateInstallationObjects$Outbound } | undefined;
};

/** @internal */
export const UpdateInstallationRead$outboundSchema: z.ZodType<
  UpdateInstallationRead$Outbound,
  z.ZodTypeDef,
  UpdateInstallationRead
> = z.object({
  objects: z.record(z.lazy(() => UpdateInstallationObjects$outboundSchema))
    .optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace UpdateInstallationRead$ {
  /** @deprecated use `UpdateInstallationRead$inboundSchema` instead. */
  export const inboundSchema = UpdateInstallationRead$inboundSchema;
  /** @deprecated use `UpdateInstallationRead$outboundSchema` instead. */
  export const outboundSchema = UpdateInstallationRead$outboundSchema;
  /** @deprecated use `UpdateInstallationRead$Outbound` instead. */
  export type Outbound = UpdateInstallationRead$Outbound;
}

export function updateInstallationReadToJSON(
  updateInstallationRead: UpdateInstallationRead,
): string {
  return JSON.stringify(
    UpdateInstallationRead$outboundSchema.parse(updateInstallationRead),
  );
}

export function updateInstallationReadFromJSON(
  jsonString: string,
): SafeParseResult<UpdateInstallationRead, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdateInstallationRead$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdateInstallationRead' from JSON`,
  );
}

/** @internal */
export const UpdateInstallationInstallationObjects$inboundSchema: z.ZodType<
  UpdateInstallationInstallationObjects,
  z.ZodTypeDef,
  unknown
> = z.object({
  objectName: z.string().optional(),
  selectedValueDefaults: z.record(z.string()).optional(),
});

/** @internal */
export type UpdateInstallationInstallationObjects$Outbound = {
  objectName?: string | undefined;
  selectedValueDefaults?: { [k: string]: string } | undefined;
};

/** @internal */
export const UpdateInstallationInstallationObjects$outboundSchema: z.ZodType<
  UpdateInstallationInstallationObjects$Outbound,
  z.ZodTypeDef,
  UpdateInstallationInstallationObjects
> = z.object({
  objectName: z.string().optional(),
  selectedValueDefaults: z.record(z.string()).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace UpdateInstallationInstallationObjects$ {
  /** @deprecated use `UpdateInstallationInstallationObjects$inboundSchema` instead. */
  export const inboundSchema =
    UpdateInstallationInstallationObjects$inboundSchema;
  /** @deprecated use `UpdateInstallationInstallationObjects$outboundSchema` instead. */
  export const outboundSchema =
    UpdateInstallationInstallationObjects$outboundSchema;
  /** @deprecated use `UpdateInstallationInstallationObjects$Outbound` instead. */
  export type Outbound = UpdateInstallationInstallationObjects$Outbound;
}

export function updateInstallationInstallationObjectsToJSON(
  updateInstallationInstallationObjects: UpdateInstallationInstallationObjects,
): string {
  return JSON.stringify(
    UpdateInstallationInstallationObjects$outboundSchema.parse(
      updateInstallationInstallationObjects,
    ),
  );
}

export function updateInstallationInstallationObjectsFromJSON(
  jsonString: string,
): SafeParseResult<UpdateInstallationInstallationObjects, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      UpdateInstallationInstallationObjects$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdateInstallationInstallationObjects' from JSON`,
  );
}

/** @internal */
export const UpdateInstallationWrite$inboundSchema: z.ZodType<
  UpdateInstallationWrite,
  z.ZodTypeDef,
  unknown
> = z.object({
  objects: z.record(
    z.lazy(() => UpdateInstallationInstallationObjects$inboundSchema),
  ).optional(),
});

/** @internal */
export type UpdateInstallationWrite$Outbound = {
  objects?:
    | { [k: string]: UpdateInstallationInstallationObjects$Outbound }
    | undefined;
};

/** @internal */
export const UpdateInstallationWrite$outboundSchema: z.ZodType<
  UpdateInstallationWrite$Outbound,
  z.ZodTypeDef,
  UpdateInstallationWrite
> = z.object({
  objects: z.record(
    z.lazy(() => UpdateInstallationInstallationObjects$outboundSchema),
  ).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace UpdateInstallationWrite$ {
  /** @deprecated use `UpdateInstallationWrite$inboundSchema` instead. */
  export const inboundSchema = UpdateInstallationWrite$inboundSchema;
  /** @deprecated use `UpdateInstallationWrite$outboundSchema` instead. */
  export const outboundSchema = UpdateInstallationWrite$outboundSchema;
  /** @deprecated use `UpdateInstallationWrite$Outbound` instead. */
  export type Outbound = UpdateInstallationWrite$Outbound;
}

export function updateInstallationWriteToJSON(
  updateInstallationWrite: UpdateInstallationWrite,
): string {
  return JSON.stringify(
    UpdateInstallationWrite$outboundSchema.parse(updateInstallationWrite),
  );
}

export function updateInstallationWriteFromJSON(
  jsonString: string,
): SafeParseResult<UpdateInstallationWrite, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdateInstallationWrite$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdateInstallationWrite' from JSON`,
  );
}

/** @internal */
export const UpdateInstallationProxy$inboundSchema: z.ZodType<
  UpdateInstallationProxy,
  z.ZodTypeDef,
  unknown
> = z.object({
  enabled: z.boolean().optional(),
});

/** @internal */
export type UpdateInstallationProxy$Outbound = {
  enabled?: boolean | undefined;
};

/** @internal */
export const UpdateInstallationProxy$outboundSchema: z.ZodType<
  UpdateInstallationProxy$Outbound,
  z.ZodTypeDef,
  UpdateInstallationProxy
> = z.object({
  enabled: z.boolean().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace UpdateInstallationProxy$ {
  /** @deprecated use `UpdateInstallationProxy$inboundSchema` instead. */
  export const inboundSchema = UpdateInstallationProxy$inboundSchema;
  /** @deprecated use `UpdateInstallationProxy$outboundSchema` instead. */
  export const outboundSchema = UpdateInstallationProxy$outboundSchema;
  /** @deprecated use `UpdateInstallationProxy$Outbound` instead. */
  export type Outbound = UpdateInstallationProxy$Outbound;
}

export function updateInstallationProxyToJSON(
  updateInstallationProxy: UpdateInstallationProxy,
): string {
  return JSON.stringify(
    UpdateInstallationProxy$outboundSchema.parse(updateInstallationProxy),
  );
}

export function updateInstallationProxyFromJSON(
  jsonString: string,
): SafeParseResult<UpdateInstallationProxy, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdateInstallationProxy$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdateInstallationProxy' from JSON`,
  );
}

/** @internal */
export const UpdateInstallationContent$inboundSchema: z.ZodType<
  UpdateInstallationContent,
  z.ZodTypeDef,
  unknown
> = z.object({
  provider: z.string().optional(),
  read: z.lazy(() => UpdateInstallationRead$inboundSchema).optional(),
  write: z.lazy(() => UpdateInstallationWrite$inboundSchema).optional(),
  proxy: z.lazy(() => UpdateInstallationProxy$inboundSchema).optional(),
});

/** @internal */
export type UpdateInstallationContent$Outbound = {
  provider?: string | undefined;
  read?: UpdateInstallationRead$Outbound | undefined;
  write?: UpdateInstallationWrite$Outbound | undefined;
  proxy?: UpdateInstallationProxy$Outbound | undefined;
};

/** @internal */
export const UpdateInstallationContent$outboundSchema: z.ZodType<
  UpdateInstallationContent$Outbound,
  z.ZodTypeDef,
  UpdateInstallationContent
> = z.object({
  provider: z.string().optional(),
  read: z.lazy(() => UpdateInstallationRead$outboundSchema).optional(),
  write: z.lazy(() => UpdateInstallationWrite$outboundSchema).optional(),
  proxy: z.lazy(() => UpdateInstallationProxy$outboundSchema).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace UpdateInstallationContent$ {
  /** @deprecated use `UpdateInstallationContent$inboundSchema` instead. */
  export const inboundSchema = UpdateInstallationContent$inboundSchema;
  /** @deprecated use `UpdateInstallationContent$outboundSchema` instead. */
  export const outboundSchema = UpdateInstallationContent$outboundSchema;
  /** @deprecated use `UpdateInstallationContent$Outbound` instead. */
  export type Outbound = UpdateInstallationContent$Outbound;
}

export function updateInstallationContentToJSON(
  updateInstallationContent: UpdateInstallationContent,
): string {
  return JSON.stringify(
    UpdateInstallationContent$outboundSchema.parse(updateInstallationContent),
  );
}

export function updateInstallationContentFromJSON(
  jsonString: string,
): SafeParseResult<UpdateInstallationContent, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdateInstallationContent$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdateInstallationContent' from JSON`,
  );
}

/** @internal */
export const UpdateInstallationConfig$inboundSchema: z.ZodType<
  UpdateInstallationConfig,
  z.ZodTypeDef,
  unknown
> = z.object({
  revisionId: z.string().optional(),
  createdBy: z.string().optional(),
  content: z.lazy(() => UpdateInstallationContent$inboundSchema).optional(),
});

/** @internal */
export type UpdateInstallationConfig$Outbound = {
  revisionId?: string | undefined;
  createdBy?: string | undefined;
  content?: UpdateInstallationContent$Outbound | undefined;
};

/** @internal */
export const UpdateInstallationConfig$outboundSchema: z.ZodType<
  UpdateInstallationConfig$Outbound,
  z.ZodTypeDef,
  UpdateInstallationConfig
> = z.object({
  revisionId: z.string().optional(),
  createdBy: z.string().optional(),
  content: z.lazy(() => UpdateInstallationContent$outboundSchema).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace UpdateInstallationConfig$ {
  /** @deprecated use `UpdateInstallationConfig$inboundSchema` instead. */
  export const inboundSchema = UpdateInstallationConfig$inboundSchema;
  /** @deprecated use `UpdateInstallationConfig$outboundSchema` instead. */
  export const outboundSchema = UpdateInstallationConfig$outboundSchema;
  /** @deprecated use `UpdateInstallationConfig$Outbound` instead. */
  export type Outbound = UpdateInstallationConfig$Outbound;
}

export function updateInstallationConfigToJSON(
  updateInstallationConfig: UpdateInstallationConfig,
): string {
  return JSON.stringify(
    UpdateInstallationConfig$outboundSchema.parse(updateInstallationConfig),
  );
}

export function updateInstallationConfigFromJSON(
  jsonString: string,
): SafeParseResult<UpdateInstallationConfig, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdateInstallationConfig$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdateInstallationConfig' from JSON`,
  );
}

/** @internal */
export const Installation$inboundSchema: z.ZodType<
  Installation,
  z.ZodTypeDef,
  unknown
> = z.object({
  connectionId: z.string().optional(),
  config: z.lazy(() => UpdateInstallationConfig$inboundSchema).optional(),
});

/** @internal */
export type Installation$Outbound = {
  connectionId?: string | undefined;
  config?: UpdateInstallationConfig$Outbound | undefined;
};

/** @internal */
export const Installation$outboundSchema: z.ZodType<
  Installation$Outbound,
  z.ZodTypeDef,
  Installation
> = z.object({
  connectionId: z.string().optional(),
  config: z.lazy(() => UpdateInstallationConfig$outboundSchema).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Installation$ {
  /** @deprecated use `Installation$inboundSchema` instead. */
  export const inboundSchema = Installation$inboundSchema;
  /** @deprecated use `Installation$outboundSchema` instead. */
  export const outboundSchema = Installation$outboundSchema;
  /** @deprecated use `Installation$Outbound` instead. */
  export type Outbound = Installation$Outbound;
}

export function installationToJSON(installation: Installation): string {
  return JSON.stringify(Installation$outboundSchema.parse(installation));
}

export function installationFromJSON(
  jsonString: string,
): SafeParseResult<Installation, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Installation$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Installation' from JSON`,
  );
}

/** @internal */
export const UpdateInstallationRequestBody$inboundSchema: z.ZodType<
  UpdateInstallationRequestBody,
  z.ZodTypeDef,
  unknown
> = z.object({
  updateMask: z.array(z.string()),
  installation: z.lazy(() => Installation$inboundSchema),
});

/** @internal */
export type UpdateInstallationRequestBody$Outbound = {
  updateMask: Array<string>;
  installation: Installation$Outbound;
};

/** @internal */
export const UpdateInstallationRequestBody$outboundSchema: z.ZodType<
  UpdateInstallationRequestBody$Outbound,
  z.ZodTypeDef,
  UpdateInstallationRequestBody
> = z.object({
  updateMask: z.array(z.string()),
  installation: z.lazy(() => Installation$outboundSchema),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace UpdateInstallationRequestBody$ {
  /** @deprecated use `UpdateInstallationRequestBody$inboundSchema` instead. */
  export const inboundSchema = UpdateInstallationRequestBody$inboundSchema;
  /** @deprecated use `UpdateInstallationRequestBody$outboundSchema` instead. */
  export const outboundSchema = UpdateInstallationRequestBody$outboundSchema;
  /** @deprecated use `UpdateInstallationRequestBody$Outbound` instead. */
  export type Outbound = UpdateInstallationRequestBody$Outbound;
}

export function updateInstallationRequestBodyToJSON(
  updateInstallationRequestBody: UpdateInstallationRequestBody,
): string {
  return JSON.stringify(
    UpdateInstallationRequestBody$outboundSchema.parse(
      updateInstallationRequestBody,
    ),
  );
}

export function updateInstallationRequestBodyFromJSON(
  jsonString: string,
): SafeParseResult<UpdateInstallationRequestBody, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdateInstallationRequestBody$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdateInstallationRequestBody' from JSON`,
  );
}

/** @internal */
export const UpdateInstallationRequest$inboundSchema: z.ZodType<
  UpdateInstallationRequest,
  z.ZodTypeDef,
  unknown
> = z.object({
  projectIdOrName: z.string(),
  integrationId: z.string(),
  installationId: z.string(),
  RequestBody: z.lazy(() => UpdateInstallationRequestBody$inboundSchema),
}).transform((v) => {
  return remap$(v, {
    "RequestBody": "requestBody",
  });
});

/** @internal */
export type UpdateInstallationRequest$Outbound = {
  projectIdOrName: string;
  integrationId: string;
  installationId: string;
  RequestBody: UpdateInstallationRequestBody$Outbound;
};

/** @internal */
export const UpdateInstallationRequest$outboundSchema: z.ZodType<
  UpdateInstallationRequest$Outbound,
  z.ZodTypeDef,
  UpdateInstallationRequest
> = z.object({
  projectIdOrName: z.string(),
  integrationId: z.string(),
  installationId: z.string(),
  requestBody: z.lazy(() => UpdateInstallationRequestBody$outboundSchema),
}).transform((v) => {
  return remap$(v, {
    requestBody: "RequestBody",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace UpdateInstallationRequest$ {
  /** @deprecated use `UpdateInstallationRequest$inboundSchema` instead. */
  export const inboundSchema = UpdateInstallationRequest$inboundSchema;
  /** @deprecated use `UpdateInstallationRequest$outboundSchema` instead. */
  export const outboundSchema = UpdateInstallationRequest$outboundSchema;
  /** @deprecated use `UpdateInstallationRequest$Outbound` instead. */
  export type Outbound = UpdateInstallationRequest$Outbound;
}

export function updateInstallationRequestToJSON(
  updateInstallationRequest: UpdateInstallationRequest,
): string {
  return JSON.stringify(
    UpdateInstallationRequest$outboundSchema.parse(updateInstallationRequest),
  );
}

export function updateInstallationRequestFromJSON(
  jsonString: string,
): SafeParseResult<UpdateInstallationRequest, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdateInstallationRequest$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdateInstallationRequest' from JSON`,
  );
}

/** @internal */
export const UpdateInstallationInstallationResponseBody$inboundSchema:
  z.ZodType<UpdateInstallationInstallationResponseBody, z.ZodTypeDef, unknown> =
    z.object({
      type: z.string().default("about:blank"),
      href: z.string().optional(),
      title: z.string().optional(),
      status: z.number().int().optional(),
      detail: z.string().optional(),
      instance: z.string().optional(),
      subsystem: z.string().optional(),
      time: z.string().datetime({ offset: true }).transform(v => new Date(v))
        .optional(),
      requestId: z.string().optional(),
      causes: z.array(z.string()).optional(),
      remedy: z.string().optional(),
      supportEmail: z.string().optional(),
      supportPhone: z.string().optional(),
      supportUrl: z.string().optional(),
      retryable: z.boolean().optional(),
      retryAfter: z.string().datetime({ offset: true }).transform(v =>
        new Date(v)
      ).optional(),
      context: z.record(z.any()).optional(),
    });

/** @internal */
export type UpdateInstallationInstallationResponseBody$Outbound = {
  type: string;
  href?: string | undefined;
  title?: string | undefined;
  status?: number | undefined;
  detail?: string | undefined;
  instance?: string | undefined;
  subsystem?: string | undefined;
  time?: string | undefined;
  requestId?: string | undefined;
  causes?: Array<string> | undefined;
  remedy?: string | undefined;
  supportEmail?: string | undefined;
  supportPhone?: string | undefined;
  supportUrl?: string | undefined;
  retryable?: boolean | undefined;
  retryAfter?: string | undefined;
  context?: { [k: string]: any } | undefined;
};

/** @internal */
export const UpdateInstallationInstallationResponseBody$outboundSchema:
  z.ZodType<
    UpdateInstallationInstallationResponseBody$Outbound,
    z.ZodTypeDef,
    UpdateInstallationInstallationResponseBody
  > = z.object({
    type: z.string().default("about:blank"),
    href: z.string().optional(),
    title: z.string().optional(),
    status: z.number().int().optional(),
    detail: z.string().optional(),
    instance: z.string().optional(),
    subsystem: z.string().optional(),
    time: z.date().transform(v => v.toISOString()).optional(),
    requestId: z.string().optional(),
    causes: z.array(z.string()).optional(),
    remedy: z.string().optional(),
    supportEmail: z.string().optional(),
    supportPhone: z.string().optional(),
    supportUrl: z.string().optional(),
    retryable: z.boolean().optional(),
    retryAfter: z.date().transform(v => v.toISOString()).optional(),
    context: z.record(z.any()).optional(),
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace UpdateInstallationInstallationResponseBody$ {
  /** @deprecated use `UpdateInstallationInstallationResponseBody$inboundSchema` instead. */
  export const inboundSchema =
    UpdateInstallationInstallationResponseBody$inboundSchema;
  /** @deprecated use `UpdateInstallationInstallationResponseBody$outboundSchema` instead. */
  export const outboundSchema =
    UpdateInstallationInstallationResponseBody$outboundSchema;
  /** @deprecated use `UpdateInstallationInstallationResponseBody$Outbound` instead. */
  export type Outbound = UpdateInstallationInstallationResponseBody$Outbound;
}

export function updateInstallationInstallationResponseBodyToJSON(
  updateInstallationInstallationResponseBody:
    UpdateInstallationInstallationResponseBody,
): string {
  return JSON.stringify(
    UpdateInstallationInstallationResponseBody$outboundSchema.parse(
      updateInstallationInstallationResponseBody,
    ),
  );
}

export function updateInstallationInstallationResponseBodyFromJSON(
  jsonString: string,
): SafeParseResult<
  UpdateInstallationInstallationResponseBody,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      UpdateInstallationInstallationResponseBody$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'UpdateInstallationInstallationResponseBody' from JSON`,
  );
}

/** @internal */
export const UpdateInstallationGroup$inboundSchema: z.ZodType<
  UpdateInstallationGroup,
  z.ZodTypeDef,
  unknown
> = z.object({
  groupRef: z.string(),
  groupName: z.string(),
  projectId: z.string(),
  createTime: z.string().datetime({ offset: true }).transform(v => new Date(v)),
  updateTime: z.string().datetime({ offset: true }).transform(v => new Date(v))
    .optional(),
});

/** @internal */
export type UpdateInstallationGroup$Outbound = {
  groupRef: string;
  groupName: string;
  projectId: string;
  createTime: string;
  updateTime?: string | undefined;
};

/** @internal */
export const UpdateInstallationGroup$outboundSchema: z.ZodType<
  UpdateInstallationGroup$Outbound,
  z.ZodTypeDef,
  UpdateInstallationGroup
> = z.object({
  groupRef: z.string(),
  groupName: z.string(),
  projectId: z.string(),
  createTime: z.date().transform(v => v.toISOString()),
  updateTime: z.date().transform(v => v.toISOString()).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace UpdateInstallationGroup$ {
  /** @deprecated use `UpdateInstallationGroup$inboundSchema` instead. */
  export const inboundSchema = UpdateInstallationGroup$inboundSchema;
  /** @deprecated use `UpdateInstallationGroup$outboundSchema` instead. */
  export const outboundSchema = UpdateInstallationGroup$outboundSchema;
  /** @deprecated use `UpdateInstallationGroup$Outbound` instead. */
  export type Outbound = UpdateInstallationGroup$Outbound;
}

export function updateInstallationGroupToJSON(
  updateInstallationGroup: UpdateInstallationGroup,
): string {
  return JSON.stringify(
    UpdateInstallationGroup$outboundSchema.parse(updateInstallationGroup),
  );
}

export function updateInstallationGroupFromJSON(
  jsonString: string,
): SafeParseResult<UpdateInstallationGroup, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdateInstallationGroup$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdateInstallationGroup' from JSON`,
  );
}

/** @internal */
export const UpdateInstallationProviderApp$inboundSchema: z.ZodType<
  UpdateInstallationProviderApp,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  projectId: z.string(),
  externalRef: z.string().optional(),
  provider: z.string(),
  clientId: z.string(),
  scopes: z.array(z.string()).optional(),
  createTime: z.string().datetime({ offset: true }).transform(v => new Date(v)),
  updateTime: z.string().datetime({ offset: true }).transform(v => new Date(v))
    .optional(),
});

/** @internal */
export type UpdateInstallationProviderApp$Outbound = {
  id: string;
  projectId: string;
  externalRef?: string | undefined;
  provider: string;
  clientId: string;
  scopes?: Array<string> | undefined;
  createTime: string;
  updateTime?: string | undefined;
};

/** @internal */
export const UpdateInstallationProviderApp$outboundSchema: z.ZodType<
  UpdateInstallationProviderApp$Outbound,
  z.ZodTypeDef,
  UpdateInstallationProviderApp
> = z.object({
  id: z.string(),
  projectId: z.string(),
  externalRef: z.string().optional(),
  provider: z.string(),
  clientId: z.string(),
  scopes: z.array(z.string()).optional(),
  createTime: z.date().transform(v => v.toISOString()),
  updateTime: z.date().transform(v => v.toISOString()).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace UpdateInstallationProviderApp$ {
  /** @deprecated use `UpdateInstallationProviderApp$inboundSchema` instead. */
  export const inboundSchema = UpdateInstallationProviderApp$inboundSchema;
  /** @deprecated use `UpdateInstallationProviderApp$outboundSchema` instead. */
  export const outboundSchema = UpdateInstallationProviderApp$outboundSchema;
  /** @deprecated use `UpdateInstallationProviderApp$Outbound` instead. */
  export type Outbound = UpdateInstallationProviderApp$Outbound;
}

export function updateInstallationProviderAppToJSON(
  updateInstallationProviderApp: UpdateInstallationProviderApp,
): string {
  return JSON.stringify(
    UpdateInstallationProviderApp$outboundSchema.parse(
      updateInstallationProviderApp,
    ),
  );
}

export function updateInstallationProviderAppFromJSON(
  jsonString: string,
): SafeParseResult<UpdateInstallationProviderApp, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdateInstallationProviderApp$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdateInstallationProviderApp' from JSON`,
  );
}

/** @internal */
export const UpdateInstallationInstallationGroup$inboundSchema: z.ZodType<
  UpdateInstallationInstallationGroup,
  z.ZodTypeDef,
  unknown
> = z.object({
  groupRef: z.string(),
  groupName: z.string(),
  projectId: z.string(),
  createTime: z.string().datetime({ offset: true }).transform(v => new Date(v)),
  updateTime: z.string().datetime({ offset: true }).transform(v => new Date(v))
    .optional(),
});

/** @internal */
export type UpdateInstallationInstallationGroup$Outbound = {
  groupRef: string;
  groupName: string;
  projectId: string;
  createTime: string;
  updateTime?: string | undefined;
};

/** @internal */
export const UpdateInstallationInstallationGroup$outboundSchema: z.ZodType<
  UpdateInstallationInstallationGroup$Outbound,
  z.ZodTypeDef,
  UpdateInstallationInstallationGroup
> = z.object({
  groupRef: z.string(),
  groupName: z.string(),
  projectId: z.string(),
  createTime: z.date().transform(v => v.toISOString()),
  updateTime: z.date().transform(v => v.toISOString()).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace UpdateInstallationInstallationGroup$ {
  /** @deprecated use `UpdateInstallationInstallationGroup$inboundSchema` instead. */
  export const inboundSchema =
    UpdateInstallationInstallationGroup$inboundSchema;
  /** @deprecated use `UpdateInstallationInstallationGroup$outboundSchema` instead. */
  export const outboundSchema =
    UpdateInstallationInstallationGroup$outboundSchema;
  /** @deprecated use `UpdateInstallationInstallationGroup$Outbound` instead. */
  export type Outbound = UpdateInstallationInstallationGroup$Outbound;
}

export function updateInstallationInstallationGroupToJSON(
  updateInstallationInstallationGroup: UpdateInstallationInstallationGroup,
): string {
  return JSON.stringify(
    UpdateInstallationInstallationGroup$outboundSchema.parse(
      updateInstallationInstallationGroup,
    ),
  );
}

export function updateInstallationInstallationGroupFromJSON(
  jsonString: string,
): SafeParseResult<UpdateInstallationInstallationGroup, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      UpdateInstallationInstallationGroup$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdateInstallationInstallationGroup' from JSON`,
  );
}

/** @internal */
export const UpdateInstallationConsumer$inboundSchema: z.ZodType<
  UpdateInstallationConsumer,
  z.ZodTypeDef,
  unknown
> = z.object({
  consumerRef: z.string(),
  consumerName: z.string(),
  projectId: z.string(),
  createTime: z.string().datetime({ offset: true }).transform(v => new Date(v)),
  updateTime: z.string().datetime({ offset: true }).transform(v => new Date(v))
    .optional(),
});

/** @internal */
export type UpdateInstallationConsumer$Outbound = {
  consumerRef: string;
  consumerName: string;
  projectId: string;
  createTime: string;
  updateTime?: string | undefined;
};

/** @internal */
export const UpdateInstallationConsumer$outboundSchema: z.ZodType<
  UpdateInstallationConsumer$Outbound,
  z.ZodTypeDef,
  UpdateInstallationConsumer
> = z.object({
  consumerRef: z.string(),
  consumerName: z.string(),
  projectId: z.string(),
  createTime: z.date().transform(v => v.toISOString()),
  updateTime: z.date().transform(v => v.toISOString()).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace UpdateInstallationConsumer$ {
  /** @deprecated use `UpdateInstallationConsumer$inboundSchema` instead. */
  export const inboundSchema = UpdateInstallationConsumer$inboundSchema;
  /** @deprecated use `UpdateInstallationConsumer$outboundSchema` instead. */
  export const outboundSchema = UpdateInstallationConsumer$outboundSchema;
  /** @deprecated use `UpdateInstallationConsumer$Outbound` instead. */
  export type Outbound = UpdateInstallationConsumer$Outbound;
}

export function updateInstallationConsumerToJSON(
  updateInstallationConsumer: UpdateInstallationConsumer,
): string {
  return JSON.stringify(
    UpdateInstallationConsumer$outboundSchema.parse(updateInstallationConsumer),
  );
}

export function updateInstallationConsumerFromJSON(
  jsonString: string,
): SafeParseResult<UpdateInstallationConsumer, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdateInstallationConsumer$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdateInstallationConsumer' from JSON`,
  );
}

/** @internal */
export const UpdateInstallationAuthScheme$inboundSchema: z.ZodNativeEnum<
  typeof UpdateInstallationAuthScheme
> = z.nativeEnum(UpdateInstallationAuthScheme);

/** @internal */
export const UpdateInstallationAuthScheme$outboundSchema: z.ZodNativeEnum<
  typeof UpdateInstallationAuthScheme
> = UpdateInstallationAuthScheme$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace UpdateInstallationAuthScheme$ {
  /** @deprecated use `UpdateInstallationAuthScheme$inboundSchema` instead. */
  export const inboundSchema = UpdateInstallationAuthScheme$inboundSchema;
  /** @deprecated use `UpdateInstallationAuthScheme$outboundSchema` instead. */
  export const outboundSchema = UpdateInstallationAuthScheme$outboundSchema;
}

/** @internal */
export const UpdateInstallationStatus$inboundSchema: z.ZodNativeEnum<
  typeof UpdateInstallationStatus
> = z.nativeEnum(UpdateInstallationStatus);

/** @internal */
export const UpdateInstallationStatus$outboundSchema: z.ZodNativeEnum<
  typeof UpdateInstallationStatus
> = UpdateInstallationStatus$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace UpdateInstallationStatus$ {
  /** @deprecated use `UpdateInstallationStatus$inboundSchema` instead. */
  export const inboundSchema = UpdateInstallationStatus$inboundSchema;
  /** @deprecated use `UpdateInstallationStatus$outboundSchema` instead. */
  export const outboundSchema = UpdateInstallationStatus$outboundSchema;
}

/** @internal */
export const UpdateInstallationAccessToken$inboundSchema: z.ZodType<
  UpdateInstallationAccessToken,
  z.ZodTypeDef,
  unknown
> = z.object({
  token: z.string(),
});

/** @internal */
export type UpdateInstallationAccessToken$Outbound = {
  token: string;
};

/** @internal */
export const UpdateInstallationAccessToken$outboundSchema: z.ZodType<
  UpdateInstallationAccessToken$Outbound,
  z.ZodTypeDef,
  UpdateInstallationAccessToken
> = z.object({
  token: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace UpdateInstallationAccessToken$ {
  /** @deprecated use `UpdateInstallationAccessToken$inboundSchema` instead. */
  export const inboundSchema = UpdateInstallationAccessToken$inboundSchema;
  /** @deprecated use `UpdateInstallationAccessToken$outboundSchema` instead. */
  export const outboundSchema = UpdateInstallationAccessToken$outboundSchema;
  /** @deprecated use `UpdateInstallationAccessToken$Outbound` instead. */
  export type Outbound = UpdateInstallationAccessToken$Outbound;
}

export function updateInstallationAccessTokenToJSON(
  updateInstallationAccessToken: UpdateInstallationAccessToken,
): string {
  return JSON.stringify(
    UpdateInstallationAccessToken$outboundSchema.parse(
      updateInstallationAccessToken,
    ),
  );
}

export function updateInstallationAccessTokenFromJSON(
  jsonString: string,
): SafeParseResult<UpdateInstallationAccessToken, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdateInstallationAccessToken$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdateInstallationAccessToken' from JSON`,
  );
}

/** @internal */
export const UpdateInstallationRefreshToken$inboundSchema: z.ZodType<
  UpdateInstallationRefreshToken,
  z.ZodTypeDef,
  unknown
> = z.object({
  token: z.string(),
});

/** @internal */
export type UpdateInstallationRefreshToken$Outbound = {
  token: string;
};

/** @internal */
export const UpdateInstallationRefreshToken$outboundSchema: z.ZodType<
  UpdateInstallationRefreshToken$Outbound,
  z.ZodTypeDef,
  UpdateInstallationRefreshToken
> = z.object({
  token: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace UpdateInstallationRefreshToken$ {
  /** @deprecated use `UpdateInstallationRefreshToken$inboundSchema` instead. */
  export const inboundSchema = UpdateInstallationRefreshToken$inboundSchema;
  /** @deprecated use `UpdateInstallationRefreshToken$outboundSchema` instead. */
  export const outboundSchema = UpdateInstallationRefreshToken$outboundSchema;
  /** @deprecated use `UpdateInstallationRefreshToken$Outbound` instead. */
  export type Outbound = UpdateInstallationRefreshToken$Outbound;
}

export function updateInstallationRefreshTokenToJSON(
  updateInstallationRefreshToken: UpdateInstallationRefreshToken,
): string {
  return JSON.stringify(
    UpdateInstallationRefreshToken$outboundSchema.parse(
      updateInstallationRefreshToken,
    ),
  );
}

export function updateInstallationRefreshTokenFromJSON(
  jsonString: string,
): SafeParseResult<UpdateInstallationRefreshToken, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdateInstallationRefreshToken$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdateInstallationRefreshToken' from JSON`,
  );
}

/** @internal */
export const UpdateInstallationOauth2AuthorizationCode$inboundSchema: z.ZodType<
  UpdateInstallationOauth2AuthorizationCode,
  z.ZodTypeDef,
  unknown
> = z.object({
  accessToken: z.lazy(() => UpdateInstallationAccessToken$inboundSchema)
    .optional(),
  refreshToken: z.lazy(() => UpdateInstallationRefreshToken$inboundSchema)
    .optional(),
  scopes: z.array(z.string()).optional(),
});

/** @internal */
export type UpdateInstallationOauth2AuthorizationCode$Outbound = {
  accessToken?: UpdateInstallationAccessToken$Outbound | undefined;
  refreshToken?: UpdateInstallationRefreshToken$Outbound | undefined;
  scopes?: Array<string> | undefined;
};

/** @internal */
export const UpdateInstallationOauth2AuthorizationCode$outboundSchema:
  z.ZodType<
    UpdateInstallationOauth2AuthorizationCode$Outbound,
    z.ZodTypeDef,
    UpdateInstallationOauth2AuthorizationCode
  > = z.object({
    accessToken: z.lazy(() => UpdateInstallationAccessToken$outboundSchema)
      .optional(),
    refreshToken: z.lazy(() => UpdateInstallationRefreshToken$outboundSchema)
      .optional(),
    scopes: z.array(z.string()).optional(),
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace UpdateInstallationOauth2AuthorizationCode$ {
  /** @deprecated use `UpdateInstallationOauth2AuthorizationCode$inboundSchema` instead. */
  export const inboundSchema =
    UpdateInstallationOauth2AuthorizationCode$inboundSchema;
  /** @deprecated use `UpdateInstallationOauth2AuthorizationCode$outboundSchema` instead. */
  export const outboundSchema =
    UpdateInstallationOauth2AuthorizationCode$outboundSchema;
  /** @deprecated use `UpdateInstallationOauth2AuthorizationCode$Outbound` instead. */
  export type Outbound = UpdateInstallationOauth2AuthorizationCode$Outbound;
}

export function updateInstallationOauth2AuthorizationCodeToJSON(
  updateInstallationOauth2AuthorizationCode:
    UpdateInstallationOauth2AuthorizationCode,
): string {
  return JSON.stringify(
    UpdateInstallationOauth2AuthorizationCode$outboundSchema.parse(
      updateInstallationOauth2AuthorizationCode,
    ),
  );
}

export function updateInstallationOauth2AuthorizationCodeFromJSON(
  jsonString: string,
): SafeParseResult<
  UpdateInstallationOauth2AuthorizationCode,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      UpdateInstallationOauth2AuthorizationCode$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'UpdateInstallationOauth2AuthorizationCode' from JSON`,
  );
}

/** @internal */
export const UpdateInstallationConnection$inboundSchema: z.ZodType<
  UpdateInstallationConnection,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  projectId: z.string(),
  provider: z.string(),
  providerApp: z.lazy(() => UpdateInstallationProviderApp$inboundSchema)
    .optional(),
  group: z.lazy(() => UpdateInstallationInstallationGroup$inboundSchema),
  consumer: z.lazy(() => UpdateInstallationConsumer$inboundSchema),
  providerWorkspaceRef: z.string().optional(),
  providerConsumerRef: z.string().optional(),
  createTime: z.string().datetime({ offset: true }).transform(v => new Date(v)),
  updateTime: z.string().datetime({ offset: true }).transform(v => new Date(v))
    .optional(),
  authScheme: UpdateInstallationAuthScheme$inboundSchema,
  status: UpdateInstallationStatus$inboundSchema,
  oauth2AuthorizationCode: z.lazy(() =>
    UpdateInstallationOauth2AuthorizationCode$inboundSchema
  ).optional(),
});

/** @internal */
export type UpdateInstallationConnection$Outbound = {
  id: string;
  projectId: string;
  provider: string;
  providerApp?: UpdateInstallationProviderApp$Outbound | undefined;
  group: UpdateInstallationInstallationGroup$Outbound;
  consumer: UpdateInstallationConsumer$Outbound;
  providerWorkspaceRef?: string | undefined;
  providerConsumerRef?: string | undefined;
  createTime: string;
  updateTime?: string | undefined;
  authScheme: string;
  status: string;
  oauth2AuthorizationCode?:
    | UpdateInstallationOauth2AuthorizationCode$Outbound
    | undefined;
};

/** @internal */
export const UpdateInstallationConnection$outboundSchema: z.ZodType<
  UpdateInstallationConnection$Outbound,
  z.ZodTypeDef,
  UpdateInstallationConnection
> = z.object({
  id: z.string(),
  projectId: z.string(),
  provider: z.string(),
  providerApp: z.lazy(() => UpdateInstallationProviderApp$outboundSchema)
    .optional(),
  group: z.lazy(() => UpdateInstallationInstallationGroup$outboundSchema),
  consumer: z.lazy(() => UpdateInstallationConsumer$outboundSchema),
  providerWorkspaceRef: z.string().optional(),
  providerConsumerRef: z.string().optional(),
  createTime: z.date().transform(v => v.toISOString()),
  updateTime: z.date().transform(v => v.toISOString()).optional(),
  authScheme: UpdateInstallationAuthScheme$outboundSchema,
  status: UpdateInstallationStatus$outboundSchema,
  oauth2AuthorizationCode: z.lazy(() =>
    UpdateInstallationOauth2AuthorizationCode$outboundSchema
  ).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace UpdateInstallationConnection$ {
  /** @deprecated use `UpdateInstallationConnection$inboundSchema` instead. */
  export const inboundSchema = UpdateInstallationConnection$inboundSchema;
  /** @deprecated use `UpdateInstallationConnection$outboundSchema` instead. */
  export const outboundSchema = UpdateInstallationConnection$outboundSchema;
  /** @deprecated use `UpdateInstallationConnection$Outbound` instead. */
  export type Outbound = UpdateInstallationConnection$Outbound;
}

export function updateInstallationConnectionToJSON(
  updateInstallationConnection: UpdateInstallationConnection,
): string {
  return JSON.stringify(
    UpdateInstallationConnection$outboundSchema.parse(
      updateInstallationConnection,
    ),
  );
}

export function updateInstallationConnectionFromJSON(
  jsonString: string,
): SafeParseResult<UpdateInstallationConnection, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdateInstallationConnection$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdateInstallationConnection' from JSON`,
  );
}

/** @internal */
export const UpdateInstallationInstallationProxy$inboundSchema: z.ZodType<
  UpdateInstallationInstallationProxy,
  z.ZodTypeDef,
  unknown
> = z.object({
  enabled: z.boolean().optional(),
});

/** @internal */
export type UpdateInstallationInstallationProxy$Outbound = {
  enabled?: boolean | undefined;
};

/** @internal */
export const UpdateInstallationInstallationProxy$outboundSchema: z.ZodType<
  UpdateInstallationInstallationProxy$Outbound,
  z.ZodTypeDef,
  UpdateInstallationInstallationProxy
> = z.object({
  enabled: z.boolean().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace UpdateInstallationInstallationProxy$ {
  /** @deprecated use `UpdateInstallationInstallationProxy$inboundSchema` instead. */
  export const inboundSchema =
    UpdateInstallationInstallationProxy$inboundSchema;
  /** @deprecated use `UpdateInstallationInstallationProxy$outboundSchema` instead. */
  export const outboundSchema =
    UpdateInstallationInstallationProxy$outboundSchema;
  /** @deprecated use `UpdateInstallationInstallationProxy$Outbound` instead. */
  export type Outbound = UpdateInstallationInstallationProxy$Outbound;
}

export function updateInstallationInstallationProxyToJSON(
  updateInstallationInstallationProxy: UpdateInstallationInstallationProxy,
): string {
  return JSON.stringify(
    UpdateInstallationInstallationProxy$outboundSchema.parse(
      updateInstallationInstallationProxy,
    ),
  );
}

export function updateInstallationInstallationProxyFromJSON(
  jsonString: string,
): SafeParseResult<UpdateInstallationInstallationProxy, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      UpdateInstallationInstallationProxy$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdateInstallationInstallationProxy' from JSON`,
  );
}

/** @internal */
export const UpdateInstallationInstallationContent$inboundSchema: z.ZodType<
  UpdateInstallationInstallationContent,
  z.ZodTypeDef,
  unknown
> = z.object({
  provider: z.string(),
  read: z.any().optional(),
  write: z.any().optional(),
  proxy: z.lazy(() => UpdateInstallationInstallationProxy$inboundSchema)
    .optional(),
});

/** @internal */
export type UpdateInstallationInstallationContent$Outbound = {
  provider: string;
  read?: any | undefined;
  write?: any | undefined;
  proxy?: UpdateInstallationInstallationProxy$Outbound | undefined;
};

/** @internal */
export const UpdateInstallationInstallationContent$outboundSchema: z.ZodType<
  UpdateInstallationInstallationContent$Outbound,
  z.ZodTypeDef,
  UpdateInstallationInstallationContent
> = z.object({
  provider: z.string(),
  read: z.any().optional(),
  write: z.any().optional(),
  proxy: z.lazy(() => UpdateInstallationInstallationProxy$outboundSchema)
    .optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace UpdateInstallationInstallationContent$ {
  /** @deprecated use `UpdateInstallationInstallationContent$inboundSchema` instead. */
  export const inboundSchema =
    UpdateInstallationInstallationContent$inboundSchema;
  /** @deprecated use `UpdateInstallationInstallationContent$outboundSchema` instead. */
  export const outboundSchema =
    UpdateInstallationInstallationContent$outboundSchema;
  /** @deprecated use `UpdateInstallationInstallationContent$Outbound` instead. */
  export type Outbound = UpdateInstallationInstallationContent$Outbound;
}

export function updateInstallationInstallationContentToJSON(
  updateInstallationInstallationContent: UpdateInstallationInstallationContent,
): string {
  return JSON.stringify(
    UpdateInstallationInstallationContent$outboundSchema.parse(
      updateInstallationInstallationContent,
    ),
  );
}

export function updateInstallationInstallationContentFromJSON(
  jsonString: string,
): SafeParseResult<UpdateInstallationInstallationContent, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      UpdateInstallationInstallationContent$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdateInstallationInstallationContent' from JSON`,
  );
}

/** @internal */
export const UpdateInstallationInstallationConfig$inboundSchema: z.ZodType<
  UpdateInstallationInstallationConfig,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  revisionId: z.string(),
  createTime: z.string().datetime({ offset: true }).transform(v => new Date(v)),
  createdBy: z.string(),
  content: z.lazy(() => UpdateInstallationInstallationContent$inboundSchema),
});

/** @internal */
export type UpdateInstallationInstallationConfig$Outbound = {
  id: string;
  revisionId: string;
  createTime: string;
  createdBy: string;
  content: UpdateInstallationInstallationContent$Outbound;
};

/** @internal */
export const UpdateInstallationInstallationConfig$outboundSchema: z.ZodType<
  UpdateInstallationInstallationConfig$Outbound,
  z.ZodTypeDef,
  UpdateInstallationInstallationConfig
> = z.object({
  id: z.string(),
  revisionId: z.string(),
  createTime: z.date().transform(v => v.toISOString()),
  createdBy: z.string(),
  content: z.lazy(() => UpdateInstallationInstallationContent$outboundSchema),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace UpdateInstallationInstallationConfig$ {
  /** @deprecated use `UpdateInstallationInstallationConfig$inboundSchema` instead. */
  export const inboundSchema =
    UpdateInstallationInstallationConfig$inboundSchema;
  /** @deprecated use `UpdateInstallationInstallationConfig$outboundSchema` instead. */
  export const outboundSchema =
    UpdateInstallationInstallationConfig$outboundSchema;
  /** @deprecated use `UpdateInstallationInstallationConfig$Outbound` instead. */
  export type Outbound = UpdateInstallationInstallationConfig$Outbound;
}

export function updateInstallationInstallationConfigToJSON(
  updateInstallationInstallationConfig: UpdateInstallationInstallationConfig,
): string {
  return JSON.stringify(
    UpdateInstallationInstallationConfig$outboundSchema.parse(
      updateInstallationInstallationConfig,
    ),
  );
}

export function updateInstallationInstallationConfigFromJSON(
  jsonString: string,
): SafeParseResult<UpdateInstallationInstallationConfig, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      UpdateInstallationInstallationConfig$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdateInstallationInstallationConfig' from JSON`,
  );
}

/** @internal */
export const UpdateInstallationResponseBody$inboundSchema: z.ZodType<
  UpdateInstallationResponseBody,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  projectId: z.string(),
  integrationId: z.string(),
  group: z.lazy(() => UpdateInstallationGroup$inboundSchema).optional(),
  healthStatus: z.string(),
  connection: z.lazy(() => UpdateInstallationConnection$inboundSchema),
  createTime: z.string().datetime({ offset: true }).transform(v => new Date(v)),
  createdBy: z.string(),
  updateTime: z.string().datetime({ offset: true }).transform(v => new Date(v))
    .optional(),
  config: z.lazy(() => UpdateInstallationInstallationConfig$inboundSchema),
});

/** @internal */
export type UpdateInstallationResponseBody$Outbound = {
  id: string;
  projectId: string;
  integrationId: string;
  group?: UpdateInstallationGroup$Outbound | undefined;
  healthStatus: string;
  connection: UpdateInstallationConnection$Outbound;
  createTime: string;
  createdBy: string;
  updateTime?: string | undefined;
  config: UpdateInstallationInstallationConfig$Outbound;
};

/** @internal */
export const UpdateInstallationResponseBody$outboundSchema: z.ZodType<
  UpdateInstallationResponseBody$Outbound,
  z.ZodTypeDef,
  UpdateInstallationResponseBody
> = z.object({
  id: z.string(),
  projectId: z.string(),
  integrationId: z.string(),
  group: z.lazy(() => UpdateInstallationGroup$outboundSchema).optional(),
  healthStatus: z.string(),
  connection: z.lazy(() => UpdateInstallationConnection$outboundSchema),
  createTime: z.date().transform(v => v.toISOString()),
  createdBy: z.string(),
  updateTime: z.date().transform(v => v.toISOString()).optional(),
  config: z.lazy(() => UpdateInstallationInstallationConfig$outboundSchema),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace UpdateInstallationResponseBody$ {
  /** @deprecated use `UpdateInstallationResponseBody$inboundSchema` instead. */
  export const inboundSchema = UpdateInstallationResponseBody$inboundSchema;
  /** @deprecated use `UpdateInstallationResponseBody$outboundSchema` instead. */
  export const outboundSchema = UpdateInstallationResponseBody$outboundSchema;
  /** @deprecated use `UpdateInstallationResponseBody$Outbound` instead. */
  export type Outbound = UpdateInstallationResponseBody$Outbound;
}

export function updateInstallationResponseBodyToJSON(
  updateInstallationResponseBody: UpdateInstallationResponseBody,
): string {
  return JSON.stringify(
    UpdateInstallationResponseBody$outboundSchema.parse(
      updateInstallationResponseBody,
    ),
  );
}

export function updateInstallationResponseBodyFromJSON(
  jsonString: string,
): SafeParseResult<UpdateInstallationResponseBody, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdateInstallationResponseBody$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdateInstallationResponseBody' from JSON`,
  );
}

/** @internal */
export const UpdateInstallationResponse$inboundSchema: z.ZodType<
  UpdateInstallationResponse,
  z.ZodTypeDef,
  unknown
> = z.union([
  z.lazy(() => UpdateInstallationResponseBody$inboundSchema),
  z.lazy(() => UpdateInstallationInstallationResponseBody$inboundSchema),
]);

/** @internal */
export type UpdateInstallationResponse$Outbound =
  | UpdateInstallationResponseBody$Outbound
  | UpdateInstallationInstallationResponseBody$Outbound;

/** @internal */
export const UpdateInstallationResponse$outboundSchema: z.ZodType<
  UpdateInstallationResponse$Outbound,
  z.ZodTypeDef,
  UpdateInstallationResponse
> = z.union([
  z.lazy(() => UpdateInstallationResponseBody$outboundSchema),
  z.lazy(() => UpdateInstallationInstallationResponseBody$outboundSchema),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace UpdateInstallationResponse$ {
  /** @deprecated use `UpdateInstallationResponse$inboundSchema` instead. */
  export const inboundSchema = UpdateInstallationResponse$inboundSchema;
  /** @deprecated use `UpdateInstallationResponse$outboundSchema` instead. */
  export const outboundSchema = UpdateInstallationResponse$outboundSchema;
  /** @deprecated use `UpdateInstallationResponse$Outbound` instead. */
  export type Outbound = UpdateInstallationResponse$Outbound;
}

export function updateInstallationResponseToJSON(
  updateInstallationResponse: UpdateInstallationResponse,
): string {
  return JSON.stringify(
    UpdateInstallationResponse$outboundSchema.parse(updateInstallationResponse),
  );
}

export function updateInstallationResponseFromJSON(
  jsonString: string,
): SafeParseResult<UpdateInstallationResponse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdateInstallationResponse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdateInstallationResponse' from JSON`,
  );
}
