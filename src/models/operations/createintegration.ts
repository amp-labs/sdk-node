/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod";
import { remap as remap$ } from "../../lib/primitives.js";
import { safeParse } from "../../lib/schemas.js";
import { ClosedEnum } from "../../types/enums.js";
import { Result as SafeParseResult } from "../../types/fp.js";
import { SDKValidationError } from "../errors/sdkvalidationerror.js";

export const CreateIntegrationServerList = [
  "https://api.withampersand.com/v1",
] as const;

export type Two = {
  mapToName: string;
  mapToDisplayName?: string | undefined;
  default?: string | undefined;
  prompt?: string | undefined;
};

export type One = {
  fieldName: string;
  /**
   * The field name to map to.
   */
  mapToName?: string | undefined;
  /**
   * The display name to map to.
   */
  mapToDisplayName?: string | undefined;
};

export type RequiredFields = One | Two;

export type OptionalFields2 = {
  mapToName: string;
  mapToDisplayName?: string | undefined;
  default?: string | undefined;
  prompt?: string | undefined;
};

export type OptionalFields1 = {
  fieldName: string;
  /**
   * The field name to map to.
   */
  mapToName?: string | undefined;
  /**
   * The display name to map to.
   */
  mapToDisplayName?: string | undefined;
};

export type OptionalFields = OptionalFields1 | OptionalFields2;

export const OptionalFieldsAuto = {
  All: "all",
} as const;
export type OptionalFieldsAuto = ClosedEnum<typeof OptionalFieldsAuto>;

export type DefaultPeriod = {
  /**
   * Number of days in past to backfill from. 0 is no backfill. e.g) if 10, then backfill last 10 days of data. Required if fullHistory is not set.
   */
  days?: number | undefined;
  /**
   * If true, backfill all history. Required if days is not set.
   */
  fullHistory?: boolean | undefined;
};

export type Backfill = {
  defaultPeriod: DefaultPeriod;
};

/**
 * The data delivery mode for this object. If not specified, defaults to automatic.
 */
export const CreateIntegrationMode = {
  OnRequest: "onRequest",
  Auto: "auto",
} as const;
/**
 * The data delivery mode for this object. If not specified, defaults to automatic.
 */
export type CreateIntegrationMode = ClosedEnum<typeof CreateIntegrationMode>;

export type Delivery = {
  /**
   * The data delivery mode for this object. If not specified, defaults to automatic.
   */
  mode?: CreateIntegrationMode | undefined;
  /**
   * The number of records to receive per data delivery.
   */
  pageSize?: number | undefined;
};

export type Objects = {
  objectName: string;
  destination: string;
  schedule: string;
  /**
   * An object name to map to.
   */
  mapToName?: string | undefined;
  /**
   * A display name to map to.
   */
  mapToDisplayName?: string | undefined;
  requiredFields?: Array<One | Two> | undefined;
  optionalFields?: Array<OptionalFields1 | OptionalFields2> | undefined;
  optionalFieldsAuto?: OptionalFieldsAuto | undefined;
  backfill?: Backfill | undefined;
  delivery?: Delivery | undefined;
};

export type Read = {
  objects?: Array<Objects> | undefined;
};

/**
 * Configuration to set default write values for object fields.
 */
export type ValueDefaults = {
  /**
   * If true, users can set default values for any field.
   */
  allowAnyFields?: boolean | undefined;
};

export type CreateIntegrationObjects = {
  objectName: string;
  /**
   * If true, the write object will inherit the mapping from the read object. If false, the write object will have no mapping.
   */
  inheritMapping?: boolean | undefined;
  /**
   * Configuration to set default write values for object fields.
   */
  valueDefaults?: ValueDefaults | undefined;
};

export type Write = {
  objects?: Array<CreateIntegrationObjects> | undefined;
};

export type Proxy = {
  enabled?: boolean | undefined;
};

export type Content = {
  name: string;
  displayName?: string | undefined;
  provider: string;
  read?: Read | undefined;
  write?: Write | undefined;
  proxy?: Proxy | undefined;
};

export type LatestRevision = {
  /**
   * The spec version string.
   */
  specVersion: string;
  content: Content;
};

export type CreateIntegrationRequestBody = {
  /**
   * The integration name.
   */
  name: string;
  /**
   * The provider name (e.g. "salesforce", "hubspot")
   */
  provider: string;
  latestRevision: LatestRevision;
};

export type CreateIntegrationRequest = {
  projectIdOrName: string;
  requestBody: CreateIntegrationRequestBody;
};

/**
 * A Problem Details object (RFC 9457).
 *
 * @remarks
 *
 * Additional properties specific to the problem type may be present.
 */
export type CreateIntegrationResponseBody = {
  /**
   * An absolute URI that identifies the problem type
   */
  type?: string | undefined;
  /**
   * An absolute URI that, when dereferenced, provides human-readable documentation for the problem type (e.g. using HTML).
   */
  href?: string | undefined;
  /**
   * A short summary of the problem type. Written in English and readable for engineers (usually not suited for non technical stakeholders and not localized).
   */
  title?: string | undefined;
  /**
   * The HTTP status code generated by the origin server for this occurrence of the problem.
   */
  status?: number | undefined;
  /**
   * A human-readable explanation specific to this occurrence of the problem
   */
  detail?: string | undefined;
  /**
   * An absolute URI that identifies the specific occurrence of the problem. It may or may not yield further information if dereferenced.
   */
  instance?: string | undefined;
  /**
   * The subsystem that generated the problem
   */
  subsystem?: string | undefined;
  /**
   * The time the problem occurred, formatted as RFC-3339
   */
  time?: Date | undefined;
  /**
   * A unique identifier for the request, useful for debugging
   */
  requestId?: string | undefined;
  /**
   * A list of problems that caused this problem. This can be used to represent multiple
   *
   * @remarks
   * root causes. There is no guaranteed ordering of the causes.
   */
  causes?: Array<string> | undefined;
  /**
   * A brief description of how to resolve the problem
   */
  remedy?: string | undefined;
  /**
   * An email address to contact for support
   */
  supportEmail?: string | undefined;
  /**
   * A phone number to contact for support
   */
  supportPhone?: string | undefined;
  /**
   * A URL to contact for support
   */
  supportUrl?: string | undefined;
  /**
   * Whether the request can be retried
   */
  retryable?: boolean | undefined;
  /**
   * A timestamp after which the request can be retried, formatted as RFC-3339
   */
  retryAfter?: Date | undefined;
  /**
   * Additional context for the problem
   */
  context?: { [k: string]: any } | undefined;
};

/** @internal */
export const Two$inboundSchema: z.ZodType<Two, z.ZodTypeDef, unknown> = z
  .object({
    mapToName: z.string(),
    mapToDisplayName: z.string().optional(),
    default: z.string().optional(),
    prompt: z.string().optional(),
  });

/** @internal */
export type Two$Outbound = {
  mapToName: string;
  mapToDisplayName?: string | undefined;
  default?: string | undefined;
  prompt?: string | undefined;
};

/** @internal */
export const Two$outboundSchema: z.ZodType<Two$Outbound, z.ZodTypeDef, Two> = z
  .object({
    mapToName: z.string(),
    mapToDisplayName: z.string().optional(),
    default: z.string().optional(),
    prompt: z.string().optional(),
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Two$ {
  /** @deprecated use `Two$inboundSchema` instead. */
  export const inboundSchema = Two$inboundSchema;
  /** @deprecated use `Two$outboundSchema` instead. */
  export const outboundSchema = Two$outboundSchema;
  /** @deprecated use `Two$Outbound` instead. */
  export type Outbound = Two$Outbound;
}

export function twoToJSON(two: Two): string {
  return JSON.stringify(Two$outboundSchema.parse(two));
}

export function twoFromJSON(
  jsonString: string,
): SafeParseResult<Two, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Two$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Two' from JSON`,
  );
}

/** @internal */
export const One$inboundSchema: z.ZodType<One, z.ZodTypeDef, unknown> = z
  .object({
    fieldName: z.string(),
    mapToName: z.string().optional(),
    mapToDisplayName: z.string().optional(),
  });

/** @internal */
export type One$Outbound = {
  fieldName: string;
  mapToName?: string | undefined;
  mapToDisplayName?: string | undefined;
};

/** @internal */
export const One$outboundSchema: z.ZodType<One$Outbound, z.ZodTypeDef, One> = z
  .object({
    fieldName: z.string(),
    mapToName: z.string().optional(),
    mapToDisplayName: z.string().optional(),
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace One$ {
  /** @deprecated use `One$inboundSchema` instead. */
  export const inboundSchema = One$inboundSchema;
  /** @deprecated use `One$outboundSchema` instead. */
  export const outboundSchema = One$outboundSchema;
  /** @deprecated use `One$Outbound` instead. */
  export type Outbound = One$Outbound;
}

export function oneToJSON(one: One): string {
  return JSON.stringify(One$outboundSchema.parse(one));
}

export function oneFromJSON(
  jsonString: string,
): SafeParseResult<One, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => One$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'One' from JSON`,
  );
}

/** @internal */
export const RequiredFields$inboundSchema: z.ZodType<
  RequiredFields,
  z.ZodTypeDef,
  unknown
> = z.union([z.lazy(() => One$inboundSchema), z.lazy(() => Two$inboundSchema)]);

/** @internal */
export type RequiredFields$Outbound = One$Outbound | Two$Outbound;

/** @internal */
export const RequiredFields$outboundSchema: z.ZodType<
  RequiredFields$Outbound,
  z.ZodTypeDef,
  RequiredFields
> = z.union([
  z.lazy(() => One$outboundSchema),
  z.lazy(() => Two$outboundSchema),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace RequiredFields$ {
  /** @deprecated use `RequiredFields$inboundSchema` instead. */
  export const inboundSchema = RequiredFields$inboundSchema;
  /** @deprecated use `RequiredFields$outboundSchema` instead. */
  export const outboundSchema = RequiredFields$outboundSchema;
  /** @deprecated use `RequiredFields$Outbound` instead. */
  export type Outbound = RequiredFields$Outbound;
}

export function requiredFieldsToJSON(requiredFields: RequiredFields): string {
  return JSON.stringify(RequiredFields$outboundSchema.parse(requiredFields));
}

export function requiredFieldsFromJSON(
  jsonString: string,
): SafeParseResult<RequiredFields, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RequiredFields$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RequiredFields' from JSON`,
  );
}

/** @internal */
export const OptionalFields2$inboundSchema: z.ZodType<
  OptionalFields2,
  z.ZodTypeDef,
  unknown
> = z.object({
  mapToName: z.string(),
  mapToDisplayName: z.string().optional(),
  default: z.string().optional(),
  prompt: z.string().optional(),
});

/** @internal */
export type OptionalFields2$Outbound = {
  mapToName: string;
  mapToDisplayName?: string | undefined;
  default?: string | undefined;
  prompt?: string | undefined;
};

/** @internal */
export const OptionalFields2$outboundSchema: z.ZodType<
  OptionalFields2$Outbound,
  z.ZodTypeDef,
  OptionalFields2
> = z.object({
  mapToName: z.string(),
  mapToDisplayName: z.string().optional(),
  default: z.string().optional(),
  prompt: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OptionalFields2$ {
  /** @deprecated use `OptionalFields2$inboundSchema` instead. */
  export const inboundSchema = OptionalFields2$inboundSchema;
  /** @deprecated use `OptionalFields2$outboundSchema` instead. */
  export const outboundSchema = OptionalFields2$outboundSchema;
  /** @deprecated use `OptionalFields2$Outbound` instead. */
  export type Outbound = OptionalFields2$Outbound;
}

export function optionalFields2ToJSON(
  optionalFields2: OptionalFields2,
): string {
  return JSON.stringify(OptionalFields2$outboundSchema.parse(optionalFields2));
}

export function optionalFields2FromJSON(
  jsonString: string,
): SafeParseResult<OptionalFields2, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => OptionalFields2$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'OptionalFields2' from JSON`,
  );
}

/** @internal */
export const OptionalFields1$inboundSchema: z.ZodType<
  OptionalFields1,
  z.ZodTypeDef,
  unknown
> = z.object({
  fieldName: z.string(),
  mapToName: z.string().optional(),
  mapToDisplayName: z.string().optional(),
});

/** @internal */
export type OptionalFields1$Outbound = {
  fieldName: string;
  mapToName?: string | undefined;
  mapToDisplayName?: string | undefined;
};

/** @internal */
export const OptionalFields1$outboundSchema: z.ZodType<
  OptionalFields1$Outbound,
  z.ZodTypeDef,
  OptionalFields1
> = z.object({
  fieldName: z.string(),
  mapToName: z.string().optional(),
  mapToDisplayName: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OptionalFields1$ {
  /** @deprecated use `OptionalFields1$inboundSchema` instead. */
  export const inboundSchema = OptionalFields1$inboundSchema;
  /** @deprecated use `OptionalFields1$outboundSchema` instead. */
  export const outboundSchema = OptionalFields1$outboundSchema;
  /** @deprecated use `OptionalFields1$Outbound` instead. */
  export type Outbound = OptionalFields1$Outbound;
}

export function optionalFields1ToJSON(
  optionalFields1: OptionalFields1,
): string {
  return JSON.stringify(OptionalFields1$outboundSchema.parse(optionalFields1));
}

export function optionalFields1FromJSON(
  jsonString: string,
): SafeParseResult<OptionalFields1, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => OptionalFields1$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'OptionalFields1' from JSON`,
  );
}

/** @internal */
export const OptionalFields$inboundSchema: z.ZodType<
  OptionalFields,
  z.ZodTypeDef,
  unknown
> = z.union([
  z.lazy(() => OptionalFields1$inboundSchema),
  z.lazy(() => OptionalFields2$inboundSchema),
]);

/** @internal */
export type OptionalFields$Outbound =
  | OptionalFields1$Outbound
  | OptionalFields2$Outbound;

/** @internal */
export const OptionalFields$outboundSchema: z.ZodType<
  OptionalFields$Outbound,
  z.ZodTypeDef,
  OptionalFields
> = z.union([
  z.lazy(() => OptionalFields1$outboundSchema),
  z.lazy(() => OptionalFields2$outboundSchema),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OptionalFields$ {
  /** @deprecated use `OptionalFields$inboundSchema` instead. */
  export const inboundSchema = OptionalFields$inboundSchema;
  /** @deprecated use `OptionalFields$outboundSchema` instead. */
  export const outboundSchema = OptionalFields$outboundSchema;
  /** @deprecated use `OptionalFields$Outbound` instead. */
  export type Outbound = OptionalFields$Outbound;
}

export function optionalFieldsToJSON(optionalFields: OptionalFields): string {
  return JSON.stringify(OptionalFields$outboundSchema.parse(optionalFields));
}

export function optionalFieldsFromJSON(
  jsonString: string,
): SafeParseResult<OptionalFields, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => OptionalFields$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'OptionalFields' from JSON`,
  );
}

/** @internal */
export const OptionalFieldsAuto$inboundSchema: z.ZodNativeEnum<
  typeof OptionalFieldsAuto
> = z.nativeEnum(OptionalFieldsAuto);

/** @internal */
export const OptionalFieldsAuto$outboundSchema: z.ZodNativeEnum<
  typeof OptionalFieldsAuto
> = OptionalFieldsAuto$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OptionalFieldsAuto$ {
  /** @deprecated use `OptionalFieldsAuto$inboundSchema` instead. */
  export const inboundSchema = OptionalFieldsAuto$inboundSchema;
  /** @deprecated use `OptionalFieldsAuto$outboundSchema` instead. */
  export const outboundSchema = OptionalFieldsAuto$outboundSchema;
}

/** @internal */
export const DefaultPeriod$inboundSchema: z.ZodType<
  DefaultPeriod,
  z.ZodTypeDef,
  unknown
> = z.object({
  days: z.number().int().optional(),
  fullHistory: z.boolean().optional(),
});

/** @internal */
export type DefaultPeriod$Outbound = {
  days?: number | undefined;
  fullHistory?: boolean | undefined;
};

/** @internal */
export const DefaultPeriod$outboundSchema: z.ZodType<
  DefaultPeriod$Outbound,
  z.ZodTypeDef,
  DefaultPeriod
> = z.object({
  days: z.number().int().optional(),
  fullHistory: z.boolean().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace DefaultPeriod$ {
  /** @deprecated use `DefaultPeriod$inboundSchema` instead. */
  export const inboundSchema = DefaultPeriod$inboundSchema;
  /** @deprecated use `DefaultPeriod$outboundSchema` instead. */
  export const outboundSchema = DefaultPeriod$outboundSchema;
  /** @deprecated use `DefaultPeriod$Outbound` instead. */
  export type Outbound = DefaultPeriod$Outbound;
}

export function defaultPeriodToJSON(defaultPeriod: DefaultPeriod): string {
  return JSON.stringify(DefaultPeriod$outboundSchema.parse(defaultPeriod));
}

export function defaultPeriodFromJSON(
  jsonString: string,
): SafeParseResult<DefaultPeriod, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => DefaultPeriod$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'DefaultPeriod' from JSON`,
  );
}

/** @internal */
export const Backfill$inboundSchema: z.ZodType<
  Backfill,
  z.ZodTypeDef,
  unknown
> = z.object({
  defaultPeriod: z.lazy(() => DefaultPeriod$inboundSchema),
});

/** @internal */
export type Backfill$Outbound = {
  defaultPeriod: DefaultPeriod$Outbound;
};

/** @internal */
export const Backfill$outboundSchema: z.ZodType<
  Backfill$Outbound,
  z.ZodTypeDef,
  Backfill
> = z.object({
  defaultPeriod: z.lazy(() => DefaultPeriod$outboundSchema),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Backfill$ {
  /** @deprecated use `Backfill$inboundSchema` instead. */
  export const inboundSchema = Backfill$inboundSchema;
  /** @deprecated use `Backfill$outboundSchema` instead. */
  export const outboundSchema = Backfill$outboundSchema;
  /** @deprecated use `Backfill$Outbound` instead. */
  export type Outbound = Backfill$Outbound;
}

export function backfillToJSON(backfill: Backfill): string {
  return JSON.stringify(Backfill$outboundSchema.parse(backfill));
}

export function backfillFromJSON(
  jsonString: string,
): SafeParseResult<Backfill, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Backfill$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Backfill' from JSON`,
  );
}

/** @internal */
export const CreateIntegrationMode$inboundSchema: z.ZodNativeEnum<
  typeof CreateIntegrationMode
> = z.nativeEnum(CreateIntegrationMode);

/** @internal */
export const CreateIntegrationMode$outboundSchema: z.ZodNativeEnum<
  typeof CreateIntegrationMode
> = CreateIntegrationMode$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateIntegrationMode$ {
  /** @deprecated use `CreateIntegrationMode$inboundSchema` instead. */
  export const inboundSchema = CreateIntegrationMode$inboundSchema;
  /** @deprecated use `CreateIntegrationMode$outboundSchema` instead. */
  export const outboundSchema = CreateIntegrationMode$outboundSchema;
}

/** @internal */
export const Delivery$inboundSchema: z.ZodType<
  Delivery,
  z.ZodTypeDef,
  unknown
> = z.object({
  mode: CreateIntegrationMode$inboundSchema.default("auto"),
  pageSize: z.number().int().optional(),
});

/** @internal */
export type Delivery$Outbound = {
  mode: string;
  pageSize?: number | undefined;
};

/** @internal */
export const Delivery$outboundSchema: z.ZodType<
  Delivery$Outbound,
  z.ZodTypeDef,
  Delivery
> = z.object({
  mode: CreateIntegrationMode$outboundSchema.default("auto"),
  pageSize: z.number().int().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Delivery$ {
  /** @deprecated use `Delivery$inboundSchema` instead. */
  export const inboundSchema = Delivery$inboundSchema;
  /** @deprecated use `Delivery$outboundSchema` instead. */
  export const outboundSchema = Delivery$outboundSchema;
  /** @deprecated use `Delivery$Outbound` instead. */
  export type Outbound = Delivery$Outbound;
}

export function deliveryToJSON(delivery: Delivery): string {
  return JSON.stringify(Delivery$outboundSchema.parse(delivery));
}

export function deliveryFromJSON(
  jsonString: string,
): SafeParseResult<Delivery, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Delivery$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Delivery' from JSON`,
  );
}

/** @internal */
export const Objects$inboundSchema: z.ZodType<Objects, z.ZodTypeDef, unknown> =
  z.object({
    objectName: z.string(),
    destination: z.string(),
    schedule: z.string(),
    mapToName: z.string().optional(),
    mapToDisplayName: z.string().optional(),
    requiredFields: z.array(
      z.union([
        z.lazy(() => One$inboundSchema),
        z.lazy(() => Two$inboundSchema),
      ]),
    ).optional(),
    optionalFields: z.array(
      z.union([
        z.lazy(() => OptionalFields1$inboundSchema),
        z.lazy(() => OptionalFields2$inboundSchema),
      ]),
    ).optional(),
    optionalFieldsAuto: OptionalFieldsAuto$inboundSchema.optional(),
    backfill: z.lazy(() => Backfill$inboundSchema).optional(),
    delivery: z.lazy(() => Delivery$inboundSchema).optional(),
  });

/** @internal */
export type Objects$Outbound = {
  objectName: string;
  destination: string;
  schedule: string;
  mapToName?: string | undefined;
  mapToDisplayName?: string | undefined;
  requiredFields?: Array<One$Outbound | Two$Outbound> | undefined;
  optionalFields?:
    | Array<OptionalFields1$Outbound | OptionalFields2$Outbound>
    | undefined;
  optionalFieldsAuto?: string | undefined;
  backfill?: Backfill$Outbound | undefined;
  delivery?: Delivery$Outbound | undefined;
};

/** @internal */
export const Objects$outboundSchema: z.ZodType<
  Objects$Outbound,
  z.ZodTypeDef,
  Objects
> = z.object({
  objectName: z.string(),
  destination: z.string(),
  schedule: z.string(),
  mapToName: z.string().optional(),
  mapToDisplayName: z.string().optional(),
  requiredFields: z.array(
    z.union([
      z.lazy(() => One$outboundSchema),
      z.lazy(() => Two$outboundSchema),
    ]),
  ).optional(),
  optionalFields: z.array(
    z.union([
      z.lazy(() => OptionalFields1$outboundSchema),
      z.lazy(() => OptionalFields2$outboundSchema),
    ]),
  ).optional(),
  optionalFieldsAuto: OptionalFieldsAuto$outboundSchema.optional(),
  backfill: z.lazy(() => Backfill$outboundSchema).optional(),
  delivery: z.lazy(() => Delivery$outboundSchema).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Objects$ {
  /** @deprecated use `Objects$inboundSchema` instead. */
  export const inboundSchema = Objects$inboundSchema;
  /** @deprecated use `Objects$outboundSchema` instead. */
  export const outboundSchema = Objects$outboundSchema;
  /** @deprecated use `Objects$Outbound` instead. */
  export type Outbound = Objects$Outbound;
}

export function objectsToJSON(objects: Objects): string {
  return JSON.stringify(Objects$outboundSchema.parse(objects));
}

export function objectsFromJSON(
  jsonString: string,
): SafeParseResult<Objects, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Objects$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Objects' from JSON`,
  );
}

/** @internal */
export const Read$inboundSchema: z.ZodType<Read, z.ZodTypeDef, unknown> = z
  .object({
    objects: z.array(z.lazy(() => Objects$inboundSchema)).optional(),
  });

/** @internal */
export type Read$Outbound = {
  objects?: Array<Objects$Outbound> | undefined;
};

/** @internal */
export const Read$outboundSchema: z.ZodType<Read$Outbound, z.ZodTypeDef, Read> =
  z.object({
    objects: z.array(z.lazy(() => Objects$outboundSchema)).optional(),
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Read$ {
  /** @deprecated use `Read$inboundSchema` instead. */
  export const inboundSchema = Read$inboundSchema;
  /** @deprecated use `Read$outboundSchema` instead. */
  export const outboundSchema = Read$outboundSchema;
  /** @deprecated use `Read$Outbound` instead. */
  export type Outbound = Read$Outbound;
}

export function readToJSON(read: Read): string {
  return JSON.stringify(Read$outboundSchema.parse(read));
}

export function readFromJSON(
  jsonString: string,
): SafeParseResult<Read, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Read$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Read' from JSON`,
  );
}

/** @internal */
export const ValueDefaults$inboundSchema: z.ZodType<
  ValueDefaults,
  z.ZodTypeDef,
  unknown
> = z.object({
  allowAnyFields: z.boolean().optional(),
});

/** @internal */
export type ValueDefaults$Outbound = {
  allowAnyFields?: boolean | undefined;
};

/** @internal */
export const ValueDefaults$outboundSchema: z.ZodType<
  ValueDefaults$Outbound,
  z.ZodTypeDef,
  ValueDefaults
> = z.object({
  allowAnyFields: z.boolean().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ValueDefaults$ {
  /** @deprecated use `ValueDefaults$inboundSchema` instead. */
  export const inboundSchema = ValueDefaults$inboundSchema;
  /** @deprecated use `ValueDefaults$outboundSchema` instead. */
  export const outboundSchema = ValueDefaults$outboundSchema;
  /** @deprecated use `ValueDefaults$Outbound` instead. */
  export type Outbound = ValueDefaults$Outbound;
}

export function valueDefaultsToJSON(valueDefaults: ValueDefaults): string {
  return JSON.stringify(ValueDefaults$outboundSchema.parse(valueDefaults));
}

export function valueDefaultsFromJSON(
  jsonString: string,
): SafeParseResult<ValueDefaults, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ValueDefaults$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ValueDefaults' from JSON`,
  );
}

/** @internal */
export const CreateIntegrationObjects$inboundSchema: z.ZodType<
  CreateIntegrationObjects,
  z.ZodTypeDef,
  unknown
> = z.object({
  objectName: z.string(),
  inheritMapping: z.boolean().optional(),
  valueDefaults: z.lazy(() => ValueDefaults$inboundSchema).optional(),
});

/** @internal */
export type CreateIntegrationObjects$Outbound = {
  objectName: string;
  inheritMapping?: boolean | undefined;
  valueDefaults?: ValueDefaults$Outbound | undefined;
};

/** @internal */
export const CreateIntegrationObjects$outboundSchema: z.ZodType<
  CreateIntegrationObjects$Outbound,
  z.ZodTypeDef,
  CreateIntegrationObjects
> = z.object({
  objectName: z.string(),
  inheritMapping: z.boolean().optional(),
  valueDefaults: z.lazy(() => ValueDefaults$outboundSchema).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateIntegrationObjects$ {
  /** @deprecated use `CreateIntegrationObjects$inboundSchema` instead. */
  export const inboundSchema = CreateIntegrationObjects$inboundSchema;
  /** @deprecated use `CreateIntegrationObjects$outboundSchema` instead. */
  export const outboundSchema = CreateIntegrationObjects$outboundSchema;
  /** @deprecated use `CreateIntegrationObjects$Outbound` instead. */
  export type Outbound = CreateIntegrationObjects$Outbound;
}

export function createIntegrationObjectsToJSON(
  createIntegrationObjects: CreateIntegrationObjects,
): string {
  return JSON.stringify(
    CreateIntegrationObjects$outboundSchema.parse(createIntegrationObjects),
  );
}

export function createIntegrationObjectsFromJSON(
  jsonString: string,
): SafeParseResult<CreateIntegrationObjects, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateIntegrationObjects$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateIntegrationObjects' from JSON`,
  );
}

/** @internal */
export const Write$inboundSchema: z.ZodType<Write, z.ZodTypeDef, unknown> = z
  .object({
    objects: z.array(z.lazy(() => CreateIntegrationObjects$inboundSchema))
      .optional(),
  });

/** @internal */
export type Write$Outbound = {
  objects?: Array<CreateIntegrationObjects$Outbound> | undefined;
};

/** @internal */
export const Write$outboundSchema: z.ZodType<
  Write$Outbound,
  z.ZodTypeDef,
  Write
> = z.object({
  objects: z.array(z.lazy(() => CreateIntegrationObjects$outboundSchema))
    .optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Write$ {
  /** @deprecated use `Write$inboundSchema` instead. */
  export const inboundSchema = Write$inboundSchema;
  /** @deprecated use `Write$outboundSchema` instead. */
  export const outboundSchema = Write$outboundSchema;
  /** @deprecated use `Write$Outbound` instead. */
  export type Outbound = Write$Outbound;
}

export function writeToJSON(write: Write): string {
  return JSON.stringify(Write$outboundSchema.parse(write));
}

export function writeFromJSON(
  jsonString: string,
): SafeParseResult<Write, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Write$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Write' from JSON`,
  );
}

/** @internal */
export const Proxy$inboundSchema: z.ZodType<Proxy, z.ZodTypeDef, unknown> = z
  .object({
    enabled: z.boolean().optional(),
  });

/** @internal */
export type Proxy$Outbound = {
  enabled?: boolean | undefined;
};

/** @internal */
export const Proxy$outboundSchema: z.ZodType<
  Proxy$Outbound,
  z.ZodTypeDef,
  Proxy
> = z.object({
  enabled: z.boolean().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Proxy$ {
  /** @deprecated use `Proxy$inboundSchema` instead. */
  export const inboundSchema = Proxy$inboundSchema;
  /** @deprecated use `Proxy$outboundSchema` instead. */
  export const outboundSchema = Proxy$outboundSchema;
  /** @deprecated use `Proxy$Outbound` instead. */
  export type Outbound = Proxy$Outbound;
}

export function proxyToJSON(proxy: Proxy): string {
  return JSON.stringify(Proxy$outboundSchema.parse(proxy));
}

export function proxyFromJSON(
  jsonString: string,
): SafeParseResult<Proxy, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Proxy$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Proxy' from JSON`,
  );
}

/** @internal */
export const Content$inboundSchema: z.ZodType<Content, z.ZodTypeDef, unknown> =
  z.object({
    name: z.string(),
    displayName: z.string().optional(),
    provider: z.string(),
    read: z.lazy(() => Read$inboundSchema).optional(),
    write: z.lazy(() => Write$inboundSchema).optional(),
    proxy: z.lazy(() => Proxy$inboundSchema).optional(),
  });

/** @internal */
export type Content$Outbound = {
  name: string;
  displayName?: string | undefined;
  provider: string;
  read?: Read$Outbound | undefined;
  write?: Write$Outbound | undefined;
  proxy?: Proxy$Outbound | undefined;
};

/** @internal */
export const Content$outboundSchema: z.ZodType<
  Content$Outbound,
  z.ZodTypeDef,
  Content
> = z.object({
  name: z.string(),
  displayName: z.string().optional(),
  provider: z.string(),
  read: z.lazy(() => Read$outboundSchema).optional(),
  write: z.lazy(() => Write$outboundSchema).optional(),
  proxy: z.lazy(() => Proxy$outboundSchema).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Content$ {
  /** @deprecated use `Content$inboundSchema` instead. */
  export const inboundSchema = Content$inboundSchema;
  /** @deprecated use `Content$outboundSchema` instead. */
  export const outboundSchema = Content$outboundSchema;
  /** @deprecated use `Content$Outbound` instead. */
  export type Outbound = Content$Outbound;
}

export function contentToJSON(content: Content): string {
  return JSON.stringify(Content$outboundSchema.parse(content));
}

export function contentFromJSON(
  jsonString: string,
): SafeParseResult<Content, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Content$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Content' from JSON`,
  );
}

/** @internal */
export const LatestRevision$inboundSchema: z.ZodType<
  LatestRevision,
  z.ZodTypeDef,
  unknown
> = z.object({
  specVersion: z.string(),
  content: z.lazy(() => Content$inboundSchema),
});

/** @internal */
export type LatestRevision$Outbound = {
  specVersion: string;
  content: Content$Outbound;
};

/** @internal */
export const LatestRevision$outboundSchema: z.ZodType<
  LatestRevision$Outbound,
  z.ZodTypeDef,
  LatestRevision
> = z.object({
  specVersion: z.string(),
  content: z.lazy(() => Content$outboundSchema),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace LatestRevision$ {
  /** @deprecated use `LatestRevision$inboundSchema` instead. */
  export const inboundSchema = LatestRevision$inboundSchema;
  /** @deprecated use `LatestRevision$outboundSchema` instead. */
  export const outboundSchema = LatestRevision$outboundSchema;
  /** @deprecated use `LatestRevision$Outbound` instead. */
  export type Outbound = LatestRevision$Outbound;
}

export function latestRevisionToJSON(latestRevision: LatestRevision): string {
  return JSON.stringify(LatestRevision$outboundSchema.parse(latestRevision));
}

export function latestRevisionFromJSON(
  jsonString: string,
): SafeParseResult<LatestRevision, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => LatestRevision$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'LatestRevision' from JSON`,
  );
}

/** @internal */
export const CreateIntegrationRequestBody$inboundSchema: z.ZodType<
  CreateIntegrationRequestBody,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string(),
  provider: z.string(),
  latestRevision: z.lazy(() => LatestRevision$inboundSchema),
});

/** @internal */
export type CreateIntegrationRequestBody$Outbound = {
  name: string;
  provider: string;
  latestRevision: LatestRevision$Outbound;
};

/** @internal */
export const CreateIntegrationRequestBody$outboundSchema: z.ZodType<
  CreateIntegrationRequestBody$Outbound,
  z.ZodTypeDef,
  CreateIntegrationRequestBody
> = z.object({
  name: z.string(),
  provider: z.string(),
  latestRevision: z.lazy(() => LatestRevision$outboundSchema),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateIntegrationRequestBody$ {
  /** @deprecated use `CreateIntegrationRequestBody$inboundSchema` instead. */
  export const inboundSchema = CreateIntegrationRequestBody$inboundSchema;
  /** @deprecated use `CreateIntegrationRequestBody$outboundSchema` instead. */
  export const outboundSchema = CreateIntegrationRequestBody$outboundSchema;
  /** @deprecated use `CreateIntegrationRequestBody$Outbound` instead. */
  export type Outbound = CreateIntegrationRequestBody$Outbound;
}

export function createIntegrationRequestBodyToJSON(
  createIntegrationRequestBody: CreateIntegrationRequestBody,
): string {
  return JSON.stringify(
    CreateIntegrationRequestBody$outboundSchema.parse(
      createIntegrationRequestBody,
    ),
  );
}

export function createIntegrationRequestBodyFromJSON(
  jsonString: string,
): SafeParseResult<CreateIntegrationRequestBody, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateIntegrationRequestBody$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateIntegrationRequestBody' from JSON`,
  );
}

/** @internal */
export const CreateIntegrationRequest$inboundSchema: z.ZodType<
  CreateIntegrationRequest,
  z.ZodTypeDef,
  unknown
> = z.object({
  projectIdOrName: z.string(),
  RequestBody: z.lazy(() => CreateIntegrationRequestBody$inboundSchema),
}).transform((v) => {
  return remap$(v, {
    "RequestBody": "requestBody",
  });
});

/** @internal */
export type CreateIntegrationRequest$Outbound = {
  projectIdOrName: string;
  RequestBody: CreateIntegrationRequestBody$Outbound;
};

/** @internal */
export const CreateIntegrationRequest$outboundSchema: z.ZodType<
  CreateIntegrationRequest$Outbound,
  z.ZodTypeDef,
  CreateIntegrationRequest
> = z.object({
  projectIdOrName: z.string(),
  requestBody: z.lazy(() => CreateIntegrationRequestBody$outboundSchema),
}).transform((v) => {
  return remap$(v, {
    requestBody: "RequestBody",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateIntegrationRequest$ {
  /** @deprecated use `CreateIntegrationRequest$inboundSchema` instead. */
  export const inboundSchema = CreateIntegrationRequest$inboundSchema;
  /** @deprecated use `CreateIntegrationRequest$outboundSchema` instead. */
  export const outboundSchema = CreateIntegrationRequest$outboundSchema;
  /** @deprecated use `CreateIntegrationRequest$Outbound` instead. */
  export type Outbound = CreateIntegrationRequest$Outbound;
}

export function createIntegrationRequestToJSON(
  createIntegrationRequest: CreateIntegrationRequest,
): string {
  return JSON.stringify(
    CreateIntegrationRequest$outboundSchema.parse(createIntegrationRequest),
  );
}

export function createIntegrationRequestFromJSON(
  jsonString: string,
): SafeParseResult<CreateIntegrationRequest, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateIntegrationRequest$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateIntegrationRequest' from JSON`,
  );
}

/** @internal */
export const CreateIntegrationResponseBody$inboundSchema: z.ZodType<
  CreateIntegrationResponseBody,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: z.string().default("about:blank"),
  href: z.string().optional(),
  title: z.string().optional(),
  status: z.number().int().optional(),
  detail: z.string().optional(),
  instance: z.string().optional(),
  subsystem: z.string().optional(),
  time: z.string().datetime({ offset: true }).transform(v => new Date(v))
    .optional(),
  requestId: z.string().optional(),
  causes: z.array(z.string()).optional(),
  remedy: z.string().optional(),
  supportEmail: z.string().optional(),
  supportPhone: z.string().optional(),
  supportUrl: z.string().optional(),
  retryable: z.boolean().optional(),
  retryAfter: z.string().datetime({ offset: true }).transform(v => new Date(v))
    .optional(),
  context: z.record(z.any()).optional(),
});

/** @internal */
export type CreateIntegrationResponseBody$Outbound = {
  type: string;
  href?: string | undefined;
  title?: string | undefined;
  status?: number | undefined;
  detail?: string | undefined;
  instance?: string | undefined;
  subsystem?: string | undefined;
  time?: string | undefined;
  requestId?: string | undefined;
  causes?: Array<string> | undefined;
  remedy?: string | undefined;
  supportEmail?: string | undefined;
  supportPhone?: string | undefined;
  supportUrl?: string | undefined;
  retryable?: boolean | undefined;
  retryAfter?: string | undefined;
  context?: { [k: string]: any } | undefined;
};

/** @internal */
export const CreateIntegrationResponseBody$outboundSchema: z.ZodType<
  CreateIntegrationResponseBody$Outbound,
  z.ZodTypeDef,
  CreateIntegrationResponseBody
> = z.object({
  type: z.string().default("about:blank"),
  href: z.string().optional(),
  title: z.string().optional(),
  status: z.number().int().optional(),
  detail: z.string().optional(),
  instance: z.string().optional(),
  subsystem: z.string().optional(),
  time: z.date().transform(v => v.toISOString()).optional(),
  requestId: z.string().optional(),
  causes: z.array(z.string()).optional(),
  remedy: z.string().optional(),
  supportEmail: z.string().optional(),
  supportPhone: z.string().optional(),
  supportUrl: z.string().optional(),
  retryable: z.boolean().optional(),
  retryAfter: z.date().transform(v => v.toISOString()).optional(),
  context: z.record(z.any()).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateIntegrationResponseBody$ {
  /** @deprecated use `CreateIntegrationResponseBody$inboundSchema` instead. */
  export const inboundSchema = CreateIntegrationResponseBody$inboundSchema;
  /** @deprecated use `CreateIntegrationResponseBody$outboundSchema` instead. */
  export const outboundSchema = CreateIntegrationResponseBody$outboundSchema;
  /** @deprecated use `CreateIntegrationResponseBody$Outbound` instead. */
  export type Outbound = CreateIntegrationResponseBody$Outbound;
}

export function createIntegrationResponseBodyToJSON(
  createIntegrationResponseBody: CreateIntegrationResponseBody,
): string {
  return JSON.stringify(
    CreateIntegrationResponseBody$outboundSchema.parse(
      createIntegrationResponseBody,
    ),
  );
}

export function createIntegrationResponseBodyFromJSON(
  jsonString: string,
): SafeParseResult<CreateIntegrationResponseBody, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateIntegrationResponseBody$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateIntegrationResponseBody' from JSON`,
  );
}
